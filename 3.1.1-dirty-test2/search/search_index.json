{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simple Management Protocol (SMP)","text":"<p>The Simple Management Protocol (SMP) for remotely managing MCU firmware.</p> <p>This package implements de/serialization of SMP messages allowing for their use on the transport of your choice.</p> <p>The SMP specification can be found here.</p>"},{"location":"#smp--usage","title":"Usage","text":"<p>SMP messages are represented as Pydantic models.  Each SMP Request and Response contains a <code>header</code> attribute that is an instance of <code>smp.header.Header</code>.  Other attributes are specific to the message type.</p> <p>For example, to create a <code>smp.os_management.EchoWriteRequest</code>:</p> <pre><code>from smp.os_management import EchoWriteRequest\n\nrequest = EchoWriteRequest(d=\"Hello world!\")\nprint(bytes(request))\n</code></pre> <p>Prints the serialized SMP Frame: <pre><code>b'\\n\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\xa1adlHello world!'\n</code></pre></p> <p>All messages can be deserialized and validated using the <code>loads()</code> method.  To  load a <code>smp.os_management.EchoWriteResponse</code>:</p> <pre><code>from smp.os_management import EchoWriteResponse\n\ndata = bytes.fromhex(\"0b00000700008c00a1617263486921\")  # data from the transport\nresponse = EchoWriteResponse.loads(data)\nprint(response)\n</code></pre> <p>Prints the deserialized SMP message representation: <pre><code>header=Header(op=&lt;OP.WRITE_RSP: 3&gt;, version=&lt;Version.V2: 1&gt;, flags=&lt;Flag: 0&gt;,\nlength=7, group_id=0, sequence=140, command_id=0) version=&lt;Version.V2: 1&gt;\nsequence=140 smp_data=b'\\x0b\\x00\\x00\\x07\\x00\\x00\\x8c\\x00\\xa1arcHi!' r='Hi!'\n</code></pre> Generally, the <code>header</code> can be ignored and the message-specific attributes are what you are interested in. <pre><code># print(response.r)\nHi!\n</code></pre> All models and their attributes are statically typed and validated; enforced by mypy linting and by Pydantic at runtime.</p>"},{"location":"#smp--serialization","title":"Serialization","text":"<p>There are a few optional arguments that are common to all SMP messages when they are created.</p> <ul> <li><code>header</code> is the SMP header.  Typically this can be left as <code>None</code> and will be     so that the header is created automatically.</li> <li><code>version</code> is the SMP version.  This defaults to <code>smp.header.Version.V2</code>.</li> <li><code>sequence</code> is the sequence number of the message.  If not provided, it will     be automatically generated using an incrementing counter.</li> </ul> <p>Take a look at <code>smp.message</code> for more information on the base classes.</p>"},{"location":"#smp--deserialization","title":"Deserialization","text":"<p>If you are writing an SMP client, then you already know the type of the incoming message because it must be a Response to your Request, or an <code>smp.error.ErrorV1</code> or <code>smp.error.ErrorV2</code>.  You can use the <code>smp.message._MessageBase.loads()</code> method that is common to all SMP messages to deserialize and validate the message.</p> <p>If you are writing an SMP server, then Python and SMP are odd choices!  Yet, you can narrow the type by first loading the header with <code>smp.header.Header.loads()</code>.</p>"},{"location":"#smp--encoding-decoding","title":"Encoding &amp; Decoding","text":"<p>The USB and serial transports defined by Zephyr use a base64 encoding and framing.  The encoding/fragmentation and decoding/reassembly is provided by  <code>smp.packet.encode()</code> and <code>smp.packet.decode()</code>.</p> <p>More information is at the Zephyr docs</p>"},{"location":"#smp--typing","title":"Typing","text":"<p>This package is meticulously typed and is intended to be used with mypy.</p>"},{"location":"#smp--validation","title":"Validation","text":"<p>All models are validated in order to detect transport and SMP server errors.  It is impossible to create an invalid SMP message or deserialize an invalid SMP message.  If you find a way, please open an issue.</p>"},{"location":"error/","title":"SMP V1 and V2 Errors","text":"<p>The Simple Management Protocol (SMP) error responses.</p>"},{"location":"error/#smp.error.T","title":"<code>T = TypeVar('T', bound=IntEnum)</code>  <code>module-attribute</code>","text":""},{"location":"error/#smp.error.MGMT_ERR","title":"<code>MGMT_ERR</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>General error codes for the Simple Management Protocol (SMP).</p> Source code in <code>smp\\error.py</code> <pre><code>@unique\nclass MGMT_ERR(IntEnum):\n    \"\"\"General error codes for the Simple Management Protocol (SMP).\"\"\"\n\n    EOK = 0\n    \"\"\"No error (success).\"\"\"\n\n    EUNKNOWN = 1\n    \"\"\"Unknown error.\"\"\"\n\n    ENOMEM = 2\n    \"\"\"Insufficient memory (likely not enough space for CBOR object).\"\"\"\n\n    EINVAL = 3\n    \"\"\"Error in input value.\"\"\"\n\n    ETIMEOUT = 4\n    \"\"\"Operation timed out.\"\"\"\n\n    ENOENT = 5\n    \"\"\"No such file/entry.\"\"\"\n\n    EBADSTATE = 6\n    \"\"\"Current state disallows command.\"\"\"\n\n    EMSGSIZE = 7\n    \"\"\"Response too large.\"\"\"\n\n    ENOTSUP = 8\n    \"\"\"Command not supported.\"\"\"\n\n    ECORRUPT = 9\n    \"\"\"Corrupt.\"\"\"\n\n    EBUSY = 10\n    \"\"\"Command blocked by processing of other command.\"\"\"\n\n    EACCESSDENIED = 11\n    \"\"\"Access to specific function, command or resource denied.\"\"\"\n\n    UNSUPPORTED_TOO_OLD = 12\n    \"\"\"Requested SMP MCUmgr protocol version is not supported (too old).\"\"\"\n\n    UNSUPPORTED_TOO_NEW = 13\n    \"\"\"Requested SMP MCUmgr protocol version is not supported (too new).\"\"\"\n\n    EPERUSER = 256\n    \"\"\"User errors defined from 256 onwards\"\"\"\n</code></pre>"},{"location":"error/#smp.error.MGMT_ERR.EOK","title":"<code>EOK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No error (success).</p>"},{"location":"error/#smp.error.MGMT_ERR.EUNKNOWN","title":"<code>EUNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown error.</p>"},{"location":"error/#smp.error.MGMT_ERR.ENOMEM","title":"<code>ENOMEM = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Insufficient memory (likely not enough space for CBOR object).</p>"},{"location":"error/#smp.error.MGMT_ERR.EINVAL","title":"<code>EINVAL = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error in input value.</p>"},{"location":"error/#smp.error.MGMT_ERR.ETIMEOUT","title":"<code>ETIMEOUT = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Operation timed out.</p>"},{"location":"error/#smp.error.MGMT_ERR.ENOENT","title":"<code>ENOENT = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No such file/entry.</p>"},{"location":"error/#smp.error.MGMT_ERR.EBADSTATE","title":"<code>EBADSTATE = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current state disallows command.</p>"},{"location":"error/#smp.error.MGMT_ERR.EMSGSIZE","title":"<code>EMSGSIZE = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Response too large.</p>"},{"location":"error/#smp.error.MGMT_ERR.ENOTSUP","title":"<code>ENOTSUP = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command not supported.</p>"},{"location":"error/#smp.error.MGMT_ERR.ECORRUPT","title":"<code>ECORRUPT = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Corrupt.</p>"},{"location":"error/#smp.error.MGMT_ERR.EBUSY","title":"<code>EBUSY = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command blocked by processing of other command.</p>"},{"location":"error/#smp.error.MGMT_ERR.EACCESSDENIED","title":"<code>EACCESSDENIED = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Access to specific function, command or resource denied.</p>"},{"location":"error/#smp.error.MGMT_ERR.UNSUPPORTED_TOO_OLD","title":"<code>UNSUPPORTED_TOO_OLD = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Requested SMP MCUmgr protocol version is not supported (too old).</p>"},{"location":"error/#smp.error.MGMT_ERR.UNSUPPORTED_TOO_NEW","title":"<code>UNSUPPORTED_TOO_NEW = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Requested SMP MCUmgr protocol version is not supported (too new).</p>"},{"location":"error/#smp.error.MGMT_ERR.EPERUSER","title":"<code>EPERUSER = 256</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>User errors defined from 256 onwards</p>"},{"location":"error/#smp.error.ErrorV1","title":"<code>ErrorV1</code>","text":"<p>               Bases: <code>Response</code></p> <p>SMP error response version 1.</p> Source code in <code>smp\\error.py</code> <pre><code>class ErrorV1(message.Response):\n    \"\"\"SMP error response version 1.\"\"\"\n\n    RESPONSE_TYPE = message.ResponseType.ERROR_V1\n\n    rc: MGMT_ERR\n    \"\"\"Error code.\"\"\"\n\n    rsn: str | None = None\n    \"\"\"Error reason.\"\"\"\n</code></pre>"},{"location":"error/#smp.error.ErrorV1.RESPONSE_TYPE","title":"<code>RESPONSE_TYPE = message.ResponseType.ERROR_V1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"error/#smp.error.ErrorV1.rc","title":"<code>rc: MGMT_ERR</code>  <code>instance-attribute</code>","text":"<p>Error code.</p>"},{"location":"error/#smp.error.ErrorV1.rsn","title":"<code>rsn: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error reason.</p>"},{"location":"error/#smp.error.Err","title":"<code>Err</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>SMP error response version 2 <code>err</code> map.</p> Source code in <code>smp\\error.py</code> <pre><code>class Err(BaseModel, Generic[T]):\n    \"\"\"SMP error response version 2 `err` map.\"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", frozen=True, arbitrary_types_allowed=True)\n\n    group: GroupId\n    rc: T\n</code></pre>"},{"location":"error/#smp.error.Err.model_config","title":"<code>model_config = ConfigDict(extra='forbid', frozen=True, arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"error/#smp.error.Err.group","title":"<code>group: GroupId</code>  <code>instance-attribute</code>","text":""},{"location":"error/#smp.error.Err.rc","title":"<code>rc: T</code>  <code>instance-attribute</code>","text":""},{"location":"error/#smp.error.ErrorV2","title":"<code>ErrorV2</code>","text":"<p>               Bases: <code>Response</code>, <code>Generic[T]</code></p> <p>SMP error response version 2.</p> Source code in <code>smp\\error.py</code> <pre><code>class ErrorV2(message.Response, Generic[T]):\n    \"\"\"SMP error response version 2.\"\"\"\n\n    RESPONSE_TYPE = message.ResponseType.ERROR_V2\n\n    err: Err[T]\n</code></pre>"},{"location":"error/#smp.error.ErrorV2.RESPONSE_TYPE","title":"<code>RESPONSE_TYPE = message.ResponseType.ERROR_V2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"error/#smp.error.ErrorV2.err","title":"<code>err: Err[T]</code>  <code>instance-attribute</code>","text":""},{"location":"exception/","title":"SMP Exceptions","text":"<p>Simple Management Protocol (SMP) runtime Python <code>Exception</code>s.</p>"},{"location":"exception/#smp.exceptions.SMPException","title":"<code>SMPException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for SMP exceptions.</p> Source code in <code>smp\\exceptions.py</code> <pre><code>class SMPException(Exception):\n    \"\"\"Base class for SMP exceptions.\"\"\"\n</code></pre>"},{"location":"exception/#smp.exceptions.SMPDecodeError","title":"<code>SMPDecodeError</code>","text":"<p>               Bases: <code>SMPException</code></p> <p>An error occurred while decoding an SMP message.</p> Source code in <code>smp\\exceptions.py</code> <pre><code>class SMPDecodeError(SMPException):\n    \"\"\"An error occurred while decoding an SMP message.\"\"\"\n</code></pre>"},{"location":"exception/#smp.exceptions.SMPBadStartDelimiter","title":"<code>SMPBadStartDelimiter</code>","text":"<p>               Bases: <code>SMPDecodeError</code></p> <p>The start delimiter of the SMP message is invalid.</p> Source code in <code>smp\\exceptions.py</code> <pre><code>class SMPBadStartDelimiter(SMPDecodeError):\n    \"\"\"The start delimiter of the SMP message is invalid.\"\"\"\n</code></pre>"},{"location":"exception/#smp.exceptions.SMPBadContinueDelimiter","title":"<code>SMPBadContinueDelimiter</code>","text":"<p>               Bases: <code>SMPDecodeError</code></p> <p>The continue delimiter of the SMP message is invalid.</p> Source code in <code>smp\\exceptions.py</code> <pre><code>class SMPBadContinueDelimiter(SMPDecodeError):\n    \"\"\"The continue delimiter of the SMP message is invalid.\"\"\"\n</code></pre>"},{"location":"exception/#smp.exceptions.SMPBadCRC","title":"<code>SMPBadCRC</code>","text":"<p>               Bases: <code>SMPDecodeError</code></p> <p>The CRC of the SMP message failed.</p> Source code in <code>smp\\exceptions.py</code> <pre><code>class SMPBadCRC(SMPDecodeError):\n    \"\"\"The CRC of the SMP message failed.\"\"\"\n</code></pre>"},{"location":"exception/#smp.exceptions.SMPDeserializationError","title":"<code>SMPDeserializationError</code>","text":"<p>               Bases: <code>SMPException</code></p> <p>Failed to deserialize an SMP message.</p> Source code in <code>smp\\exceptions.py</code> <pre><code>class SMPDeserializationError(SMPException):\n    \"\"\"Failed to deserialize an SMP message.\"\"\"\n</code></pre>"},{"location":"exception/#smp.exceptions.SMPMismatchedGroupId","title":"<code>SMPMismatchedGroupId</code>","text":"<p>               Bases: <code>SMPDeserializationError</code></p> <p>Group ID in the SMP message does not match the expected group.</p> Source code in <code>smp\\exceptions.py</code> <pre><code>class SMPMismatchedGroupId(SMPDeserializationError):\n    \"\"\"Group ID in the SMP message does not match the expected group.\"\"\"\n</code></pre>"},{"location":"exception/#smp.exceptions.SMPMalformed","title":"<code>SMPMalformed</code>","text":"<p>               Bases: <code>SMPException</code></p> <p>The SMP message is malformed.</p> Source code in <code>smp\\exceptions.py</code> <pre><code>class SMPMalformed(SMPException):\n    \"\"\"The SMP message is malformed.\"\"\"\n</code></pre>"},{"location":"file_management/","title":"File Management","text":"<p>The Simple Management Protocol (SMP) File Management group.</p>"},{"location":"file_management/#smp.file_management.FileDownloadRequest","title":"<code>FileDownloadRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Download contents of an existing file from specified path.</p> <p>Client applications must keep track of data they have already downloaded and where their position in the file is, and issue subsequent requests, with modified offset, to gather the entire file.</p> <p>Request does not carry size of requested chunk, the size is specified by application itself. Note that file handles will remain open for consecutive requests (as long as an idle timeout has not been reached and another transport does not make use of uploading/downloading files using fs_mgmt), but files are not exclusively owned by SMP, for the time of download session, and may change between requests or even be removed.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileDownloadRequest(message.ReadRequest):\n    \"\"\"Download contents of an existing file from specified path.\n\n    Client applications must keep track of data they have already downloaded and\n    where their position in the file is, and issue subsequent requests, with\n    modified offset, to gather the entire file.\n\n    Request does not carry size of requested chunk, the size is specified by\n    application itself. Note that file handles will remain open for consecutive\n    requests (as long as an idle timeout has not been reached and another\n    transport does not make use of uploading/downloading files using fs_mgmt),\n    but files are not exclusively owned by SMP, for the time of download\n    session, and may change between requests or even be removed.\n    \"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_DOWNLOAD_UPLOAD\n\n    off: int\n    \"\"\"Offset in the file to read from.\"\"\"\n    name: str\n    \"\"\"Name of the file to download.\"\"\"\n</code></pre>"},{"location":"file_management/#smp.file_management.FileDownloadRequest.off","title":"<code>off: int</code>  <code>instance-attribute</code>","text":"<p>Offset in the file to read from.</p>"},{"location":"file_management/#smp.file_management.FileDownloadRequest.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the file to download.</p>"},{"location":"file_management/#smp.file_management.FileDownloadResponse","title":"<code>FileDownloadResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Success response to a file download request.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileDownloadResponse(message.ReadResponse):\n    \"\"\"Success response to a file download request.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_DOWNLOAD_UPLOAD\n\n    off: int\n    \"\"\"Offset that this response is for.\"\"\"\n    data: bytes\n    \"\"\"Data read from the file.\"\"\"\n    len: int | None = None\n    \"\"\"The length of the file, only mandatory if \u201coff\u201d is 0.\"\"\"\n</code></pre>"},{"location":"file_management/#smp.file_management.FileDownloadResponse.off","title":"<code>off: int</code>  <code>instance-attribute</code>","text":"<p>Offset that this response is for.</p>"},{"location":"file_management/#smp.file_management.FileDownloadResponse.data","title":"<code>data: bytes</code>  <code>instance-attribute</code>","text":"<p>Data read from the file.</p>"},{"location":"file_management/#smp.file_management.FileDownloadResponse.len","title":"<code>len: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The length of the file, only mandatory if \u201coff\u201d is 0.</p>"},{"location":"file_management/#smp.file_management.FileUploadRequest","title":"<code>FileUploadRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Upload a file to a specified location.</p> <p>Command will automatically overwrite existing file or create a new one if it does not exist at specified path. The protocol supports stateless upload where each requests carries different chunk of a file and it is client side responsibility to track progress of upload.</p> <p>Note that file handles will remain open for consecutive requests (as long as an idle timeout has not been reached, but files are not exclusively owned by SMP, for the time of download session, and may change between requests or even be removed. Note that file handles will remain open for consecutive requests (as long as an idle timeout has not been reached and another transport does not make use of uploading/downloading files using fs_mgmt), but files are not exclusively owned by MCUmgr, for the time of download session, and may change between requests or even be removed.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileUploadRequest(message.WriteRequest):\n    \"\"\"Upload a file to a specified location.\n\n    Command will automatically overwrite existing file or create a new one if it\n    does not exist at specified path. The protocol supports stateless upload\n    where each requests carries different chunk of a file and it is client side\n    responsibility to track progress of upload.\n\n    Note that file handles will remain open for consecutive requests (as long as\n    an idle timeout has not been reached, but files are not exclusively owned by\n    SMP, for the time of download session, and may change between requests or\n    even be removed. Note that file handles will remain open for consecutive\n    requests (as long as an idle timeout has not been reached and another\n    transport does not make use of uploading/downloading files using fs_mgmt),\n    but files are not exclusively owned by MCUmgr, for the time of download\n    session, and may change between requests or even be removed.\n    \"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_DOWNLOAD_UPLOAD\n\n    off: int\n    \"\"\"Offset to start/continue writing to.\"\"\"\n    data: bytes\n    \"\"\"Data to write to the file.\"\"\"\n    name: str\n    \"\"\"Name of the file to upload.\"\"\"\n    len: int | None = None\n    \"\"\"The length of the file, only mandatory if \u201coff\u201d is 0.\"\"\"\n</code></pre>"},{"location":"file_management/#smp.file_management.FileUploadRequest.off","title":"<code>off: int</code>  <code>instance-attribute</code>","text":"<p>Offset to start/continue writing to.</p>"},{"location":"file_management/#smp.file_management.FileUploadRequest.data","title":"<code>data: bytes</code>  <code>instance-attribute</code>","text":"<p>Data to write to the file.</p>"},{"location":"file_management/#smp.file_management.FileUploadRequest.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the file to upload.</p>"},{"location":"file_management/#smp.file_management.FileUploadRequest.len","title":"<code>len: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The length of the file, only mandatory if \u201coff\u201d is 0.</p>"},{"location":"file_management/#smp.file_management.FileUploadResponse","title":"<code>FileUploadResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to a file upload request.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileUploadResponse(message.WriteResponse):\n    \"\"\"Success response to a file upload request.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_DOWNLOAD_UPLOAD\n\n    off: int\n    \"\"\"Offset of the file.\"\"\"\n</code></pre>"},{"location":"file_management/#smp.file_management.FileUploadResponse.off","title":"<code>off: int</code>  <code>instance-attribute</code>","text":"<p>Offset of the file.</p>"},{"location":"file_management/#smp.file_management.FileStatusRequest","title":"<code>FileStatusRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Retrieve status of an existing file from specified path of a target device.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileStatusRequest(message.ReadRequest):\n    \"\"\"Retrieve status of an existing file from specified path of a target device.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_STATUS\n\n    name: str\n</code></pre>"},{"location":"file_management/#smp.file_management.FileStatusRequest.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"file_management/#smp.file_management.FileStatusResponse","title":"<code>FileStatusResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Success response to a file status request.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileStatusResponse(message.ReadResponse):\n    \"\"\"Success response to a file status request.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_STATUS\n\n    len: int\n</code></pre>"},{"location":"file_management/#smp.file_management.FileStatusResponse.len","title":"<code>len: int</code>  <code>instance-attribute</code>","text":""},{"location":"file_management/#smp.file_management.FileHashChecksumRequest","title":"<code>FileHashChecksumRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Generate a hash/checksum of an existing file at a specified path on a target device.</p> <p>Note that kernel heap memory is required for buffers to be allocated for this to function, and large stack memory buffers are required for generation of the output hash/checksum. Requires <code>CONFIG_MCUMGR_GRP_FS_CHECKSUM_HASH</code> to be enabled for the base functionality, supported hash/checksum are opt-in with <code>CONFIG_MCUMGR_GRP_FS_CHECKSUM_IEEE_CRC32</code> or <code>CONFIG_MCUMGR_GRP_FS_HASH_SHA256</code>.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileHashChecksumRequest(message.ReadRequest):\n    \"\"\"Generate a hash/checksum of an existing file at a specified path on a target device.\n\n    Note that kernel heap memory is required for buffers to be allocated for\n    this to function, and large stack memory buffers are required for generation\n    of the output hash/checksum. Requires `CONFIG_MCUMGR_GRP_FS_CHECKSUM_HASH` to\n    be enabled for the base functionality, supported hash/checksum are opt-in\n    with `CONFIG_MCUMGR_GRP_FS_CHECKSUM_IEEE_CRC32` or\n    `CONFIG_MCUMGR_GRP_FS_HASH_SHA256`.\n    \"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_HASH_CHECKSUM\n\n    name: str\n    \"\"\"Absolute path to the file to generate hash/checksum for.\"\"\"\n    type: Literal[\"crc32\", \"sha256\"] | None = None\n    \"\"\"Type of hash/checksum to generate, if not provided, default is used.\"\"\"\n    off: int | None = None\n    \"\"\"Offset to start hash/checksum generation from, default 0.\"\"\"\n    len: int | None = None\n    \"\"\"Maximum length of the file to generate hash/checksum for, default is entire file.\"\"\"\n</code></pre>"},{"location":"file_management/#smp.file_management.FileHashChecksumRequest.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Absolute path to the file to generate hash/checksum for.</p>"},{"location":"file_management/#smp.file_management.FileHashChecksumRequest.type","title":"<code>type: Literal['crc32', 'sha256'] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Type of hash/checksum to generate, if not provided, default is used.</p>"},{"location":"file_management/#smp.file_management.FileHashChecksumRequest.off","title":"<code>off: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Offset to start hash/checksum generation from, default 0.</p>"},{"location":"file_management/#smp.file_management.FileHashChecksumRequest.len","title":"<code>len: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum length of the file to generate hash/checksum for, default is entire file.</p>"},{"location":"file_management/#smp.file_management.FileHashChecksumResponse","title":"<code>FileHashChecksumResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Success response to a file hash/checksum request.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileHashChecksumResponse(message.ReadResponse):\n    \"\"\"Success response to a file hash/checksum request.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_HASH_CHECKSUM\n\n    type: Literal[\"crc32\", \"sha256\"]\n    off: int | None = None\n    \"\"\"Only present if not 0.\"\"\"\n    len: int\n    \"\"\"Length of input data used to generate hash/checksum.\"\"\"\n    output: int | bytes\n    \"\"\"Output hash/checksum, depending on the type requested.\"\"\"\n</code></pre>"},{"location":"file_management/#smp.file_management.FileHashChecksumResponse.type","title":"<code>type: Literal['crc32', 'sha256']</code>  <code>instance-attribute</code>","text":""},{"location":"file_management/#smp.file_management.FileHashChecksumResponse.off","title":"<code>off: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Only present if not 0.</p>"},{"location":"file_management/#smp.file_management.FileHashChecksumResponse.len","title":"<code>len: int</code>  <code>instance-attribute</code>","text":"<p>Length of input data used to generate hash/checksum.</p>"},{"location":"file_management/#smp.file_management.FileHashChecksumResponse.output","title":"<code>output: int | bytes</code>  <code>instance-attribute</code>","text":"<p>Output hash/checksum, depending on the type requested.</p>"},{"location":"file_management/#smp.file_management.SupportedFileHashChecksumTypesRequest","title":"<code>SupportedFileHashChecksumTypesRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>List the hash and checksum types are available on a device.</p> <p>Requires Kconfig <code>CONFIG_MCUMGR_GRP_FS_CHECKSUM_HASH_SUPPORTED_CMD</code> to be enabled.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class SupportedFileHashChecksumTypesRequest(message.ReadRequest):\n    \"\"\"List the hash and checksum types are available on a device.\n\n    Requires Kconfig `CONFIG_MCUMGR_GRP_FS_CHECKSUM_HASH_SUPPORTED_CMD` to be enabled.\n    \"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.SUPPORTED_FILE_HASH_CHECKSUM_TYPES\n</code></pre>"},{"location":"file_management/#smp.file_management.HashChecksumFormat","title":"<code>HashChecksumFormat</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Format that the hash/checksum returns where 0 is for numerical and 1 is for byte array.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class HashChecksumFormat(IntEnum):\n    \"\"\"Format that the hash/checksum returns where 0 is for numerical and 1 is for byte array.\"\"\"\n\n    NUMERICAL = 0\n    BYTE_ARRAY = 1\n</code></pre>"},{"location":"file_management/#smp.file_management.HashChecksumFormat.NUMERICAL","title":"<code>NUMERICAL = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"file_management/#smp.file_management.HashChecksumFormat.BYTE_ARRAY","title":"<code>BYTE_ARRAY = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"file_management/#smp.file_management.HashChecksumType","title":"<code>HashChecksumType</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Hash and checksum type supported by the device.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class HashChecksumType(BaseModel):\n    \"\"\"Hash and checksum type supported by the device.\"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", frozen=True)\n\n    format: HashChecksumFormat\n    \"\"\"Format that the hash/checksum returns where 0 is for numerical and 1 is for byte array.\"\"\"\n    size: int\n    \"\"\"Size of the hash/checksum in bytes.\"\"\"\n</code></pre>"},{"location":"file_management/#smp.file_management.HashChecksumType.model_config","title":"<code>model_config = ConfigDict(extra='forbid', frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"file_management/#smp.file_management.HashChecksumType.format","title":"<code>format: HashChecksumFormat</code>  <code>instance-attribute</code>","text":"<p>Format that the hash/checksum returns where 0 is for numerical and 1 is for byte array.</p>"},{"location":"file_management/#smp.file_management.HashChecksumType.size","title":"<code>size: int</code>  <code>instance-attribute</code>","text":"<p>Size of the hash/checksum in bytes.</p>"},{"location":"file_management/#smp.file_management.SupportedFileHashChecksumTypesResponse","title":"<code>SupportedFileHashChecksumTypesResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Success response to a supported file hash/checksum types request.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class SupportedFileHashChecksumTypesResponse(message.ReadResponse):\n    \"\"\"Success response to a supported file hash/checksum types request.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.SUPPORTED_FILE_HASH_CHECKSUM_TYPES\n\n    types: Dict[Literal[\"crc32\", \"sha256\"], HashChecksumType]\n    \"\"\"The map of supported hash/checksum types.\"\"\"\n</code></pre>"},{"location":"file_management/#smp.file_management.SupportedFileHashChecksumTypesResponse.types","title":"<code>types: Dict[Literal['crc32', 'sha256'], HashChecksumType]</code>  <code>instance-attribute</code>","text":"<p>The map of supported hash/checksum types.</p>"},{"location":"file_management/#smp.file_management.FileCloseRequest","title":"<code>FileCloseRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Close all open file handles held by fs_mgmt upload/download requests.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileCloseRequest(message.WriteRequest):\n    \"\"\"Close all open file handles held by fs_mgmt upload/download requests.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_CLOSE\n</code></pre>"},{"location":"file_management/#smp.file_management.FileCloseResponse","title":"<code>FileCloseResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to a file close request.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileCloseResponse(message.WriteResponse):\n    \"\"\"Success response to a file close request.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.FileManagement.FILE_CLOSE\n</code></pre>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR","title":"<code>FS_MGMT_ERR</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>File System Management error codes.</p> Source code in <code>smp\\file_management.py</code> <pre><code>@unique\nclass FS_MGMT_ERR(IntEnum):\n    \"\"\"File System Management error codes.\"\"\"\n\n    OK = 0\n    \"\"\"No error (success).\"\"\"\n\n    UNKNOWN = 1\n    \"\"\" Unknown error. \"\"\"\n\n    FILE_INVALID_NAME = 2\n    \"\"\"The specified file name is not valid.\"\"\"\n\n    FILE_NOT_FOUND = 3\n    \"\"\"The specified file does not exist.\"\"\"\n\n    FILE_IS_DIRECTORY = 4\n    \"\"\"The specified file is a directory, not a file. \"\"\"\n\n    FILE_OPEN_FAILED = 5\n    \"\"\"Error occurred whilst attempting to open a file.\"\"\"\n\n    FILE_SEEK_FAILED = 6\n    \"\"\"Error occurred whilst attempting to seek to an offset in a file. \"\"\"\n\n    FILE_READ_FAILED = 7\n    \"\"\"Error occurred whilst attempting to read data from a file.\"\"\"\n\n    FILE_TRUNCATE_FAILED = 8\n    \"\"\"Error occurred whilst trying to truncate file.\"\"\"\n\n    FILE_DELETE_FAILED = 9\n    \"\"\"Error occurred whilst trying to delete file.\"\"\"\n\n    FILE_WRITE_FAILED = 10\n    \"\"\"Error occurred whilst attempting to write data to a file.\"\"\"\n\n    FILE_OFFSET_NOT_VALID = 11\n    \"\"\"The specified data offset is not valid, this could indicate that the file on the device has\n    changed since the previous command. The length of the current file on the device is returned as\n    \"len\", the user application needs to decide how to handle this (e.g. the hash of the file could\n    be requested and compared with the hash of the length of the file being uploaded to see if they\n    match or not).\"\"\"\n\n    FILE_OFFSET_LARGER_THAN_FILE = 12\n    \"\"\"The requested offset is larger than the size of the file on the device.\"\"\"\n\n    CHECKSUM_HASH_NOT_FOUND = 13\n    \"\"\"The requested checksum or hash type was not found or is not supported by this build.\"\"\"\n\n    MOUNT_POINT_NOT_FOUND = 14\n    \"\"\"The specified mount point was not found or is not mounted.\"\"\"\n\n    READ_ONLY_FILESYSTEM = 15\n    \"\"\"The specified mount point is that of a read-only filesystem.\"\"\"\n\n    FILE_EMPTY = 16\n    \"\"\"The operation cannot be performed because the file is empty with no contents. \"\"\"\n</code></pre>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No error (success).</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown error.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_INVALID_NAME","title":"<code>FILE_INVALID_NAME = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The specified file name is not valid.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_NOT_FOUND","title":"<code>FILE_NOT_FOUND = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The specified file does not exist.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_IS_DIRECTORY","title":"<code>FILE_IS_DIRECTORY = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The specified file is a directory, not a file.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_OPEN_FAILED","title":"<code>FILE_OPEN_FAILED = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error occurred whilst attempting to open a file.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_SEEK_FAILED","title":"<code>FILE_SEEK_FAILED = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error occurred whilst attempting to seek to an offset in a file.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_READ_FAILED","title":"<code>FILE_READ_FAILED = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error occurred whilst attempting to read data from a file.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_TRUNCATE_FAILED","title":"<code>FILE_TRUNCATE_FAILED = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error occurred whilst trying to truncate file.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_DELETE_FAILED","title":"<code>FILE_DELETE_FAILED = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error occurred whilst trying to delete file.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_WRITE_FAILED","title":"<code>FILE_WRITE_FAILED = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Error occurred whilst attempting to write data to a file.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_OFFSET_NOT_VALID","title":"<code>FILE_OFFSET_NOT_VALID = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The specified data offset is not valid, this could indicate that the file on the device has changed since the previous command. The length of the current file on the device is returned as \"len\", the user application needs to decide how to handle this (e.g. the hash of the file could be requested and compared with the hash of the length of the file being uploaded to see if they match or not).</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_OFFSET_LARGER_THAN_FILE","title":"<code>FILE_OFFSET_LARGER_THAN_FILE = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The requested offset is larger than the size of the file on the device.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.CHECKSUM_HASH_NOT_FOUND","title":"<code>CHECKSUM_HASH_NOT_FOUND = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The requested checksum or hash type was not found or is not supported by this build.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.MOUNT_POINT_NOT_FOUND","title":"<code>MOUNT_POINT_NOT_FOUND = 14</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The specified mount point was not found or is not mounted.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.READ_ONLY_FILESYSTEM","title":"<code>READ_ONLY_FILESYSTEM = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The specified mount point is that of a read-only filesystem.</p>"},{"location":"file_management/#smp.file_management.FS_MGMT_ERR.FILE_EMPTY","title":"<code>FILE_EMPTY = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The operation cannot be performed because the file is empty with no contents.</p>"},{"location":"file_management/#smp.file_management.FileSystemManagementErrorV1","title":"<code>FileSystemManagementErrorV1</code>","text":"<p>               Bases: <code>ErrorV1</code></p> <p>File System Management error response.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileSystemManagementErrorV1(error.ErrorV1):\n    \"\"\"File System Management error response.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n</code></pre>"},{"location":"file_management/#smp.file_management.FileSystemManagementErrorV2","title":"<code>FileSystemManagementErrorV2</code>","text":"<p>               Bases: <code>ErrorV2[FS_MGMT_ERR]</code></p> <p>File System Management error response.</p> Source code in <code>smp\\file_management.py</code> <pre><code>class FileSystemManagementErrorV2(error.ErrorV2[FS_MGMT_ERR]):\n    \"\"\"File System Management error response.\"\"\"\n\n    _GROUP_ID = header.GroupId.FILE_MANAGEMENT\n</code></pre>"},{"location":"image_management/","title":"Image Management","text":"<p>The Simple Management Protocol (SMP) Image Management group.</p>"},{"location":"image_management/#smp.image_management--notion-of-slots-and-images-in-zephyr","title":"Notion of \"slots\" and \"images\" in Zephyr","text":"<p>The \u201cslot\u201d and \u201cimage\u201d definition comes from mcuboot where \u201cimage\u201d would consist of two \u201cslots\u201d, further named \u201cprimary\u201d and \u201csecondary\u201d; the application is supposed to run from the \u201cprimary slot\u201d and update is supposed to be uploaded to the \u201csecondary slot\u201d; the mcuboot is responsible in swapping slots on boot. This means that pair of slots is dedicated to single upgradable application. In case of Zephyr this gets a little bit confusing because DTS will use \u201cslot0_partition\u201d and \u201cslot1_partition\u201d, as label of fixed-partition dedicated to single application, but will name them as \u201cimage-0\u201d and \u201cimage-1\u201d respectively.</p> <p>Currently Zephyr supports at most two images, in which case mapping is as follows:</p> Image Slot labels Slot Names 0 \u201cslot0_partition\u201d \u201cslot1_partition\u201d \u201cimage-0\u201d \u201cimage-1\u201d 1 \u201cslot2_partition\u201d \u201cslot3_partition\u201d \u201cimage-2\u201d \u201cimage-3\u201d"},{"location":"image_management/#smp.image_management.HashBytes","title":"<code>HashBytes</code>","text":"<p>               Bases: <code>bytes</code></p> <p>Only to print something useful to the <code>rich</code> console.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class HashBytes(bytes):  # pragma: no cover\n    \"\"\"Only to print something useful to the `rich` console.\"\"\"\n\n    def __rich_repr__(self) -&gt; Generator[str, None, None]:\n        yield self.hex().upper()\n</code></pre>"},{"location":"image_management/#smp.image_management.HashBytes.__rich_repr__","title":"<code>__rich_repr__() -&gt; Generator[str, None, None]</code>","text":"Source code in <code>smp\\image_management.py</code> <pre><code>def __rich_repr__(self) -&gt; Generator[str, None, None]:\n    yield self.hex().upper()\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageState","title":"<code>ImageState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The state of an image in a slot.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageState(BaseModel):\n    \"\"\"The state of an image in a slot.\"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", frozen=True, arbitrary_types_allowed=True)\n\n    slot: int\n    \"\"\"Slot number within \u201cimage\u201d.\n\n    Each image has two slots:\n    - primary (running one) = 0\n    - secondary (for DFU dual-bank purposes) = 1.\n    \"\"\"\n    version: str\n    \"\"\"Version of the image.\"\"\"\n    image: int | None = None\n    \"\"\"Semi-optional image number.\n\n    The field is not required when only one image is supported by the running\n    application.\n    \"\"\"\n    hash: HashBytes | bytes | None = None\n    \"\"\"SHA256 hash of the image header and body.\n\n    Note that this will not be the same as the SHA256 of the whole file, it is\n    the field in the MCUboot TLV section that contains a hash of the data which\n    is used for signature verification purposes. This field is optional but only\n    optional when using MCUboot's serial recovery feature with one pair of image\n    slots, `CONFIG_BOOT_SERIAL_IMG_GRP_HASH` can be disabled to remove\n    support for hashes in this configuration. SMP server in applications must\n    support sending hashes.\n    \"\"\"\n    bootable: bool | None = None\n    \"\"\"True if image has bootable flag set.\n\n    This field does not have to be present if false.\n    \"\"\"\n    pending: bool | None = None\n    \"\"\"True if image is set for next swap.\n\n    This field does not have to be present if false.\n    \"\"\"\n    confirmed: bool | None = None\n    \"\"\"True if image has been confirmed.\n\n    This field does not have to be present if false.\n    \"\"\"\n    active: bool | None = None\n    \"\"\"True if image is currently active application\n\n    This field does not have to be present if false.\n    \"\"\"\n    permanent: bool | None = None\n    \"\"\"True if image is to stay in primary slot after the next boot.\n\n    This does not have to be present if false.\n    \"\"\"\n\n    @field_validator(\"hash\")\n    @classmethod\n    def cast_bytes(cls, v: bytes | None, _: ValidationInfo) -&gt; HashBytes | None:\n        if v is None:\n            return None\n        return HashBytes(v)\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageState.model_config","title":"<code>model_config = ConfigDict(extra='forbid', frozen=True, arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"image_management/#smp.image_management.ImageState.slot","title":"<code>slot: int</code>  <code>instance-attribute</code>","text":"<p>Slot number within \u201cimage\u201d.</p> <p>Each image has two slots: - primary (running one) = 0 - secondary (for DFU dual-bank purposes) = 1.</p>"},{"location":"image_management/#smp.image_management.ImageState.version","title":"<code>version: str</code>  <code>instance-attribute</code>","text":"<p>Version of the image.</p>"},{"location":"image_management/#smp.image_management.ImageState.image","title":"<code>image: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Semi-optional image number.</p> <p>The field is not required when only one image is supported by the running application.</p>"},{"location":"image_management/#smp.image_management.ImageState.hash","title":"<code>hash: HashBytes | bytes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SHA256 hash of the image header and body.</p> <p>Note that this will not be the same as the SHA256 of the whole file, it is the field in the MCUboot TLV section that contains a hash of the data which is used for signature verification purposes. This field is optional but only optional when using MCUboot's serial recovery feature with one pair of image slots, <code>CONFIG_BOOT_SERIAL_IMG_GRP_HASH</code> can be disabled to remove support for hashes in this configuration. SMP server in applications must support sending hashes.</p>"},{"location":"image_management/#smp.image_management.ImageState.bootable","title":"<code>bootable: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>True if image has bootable flag set.</p> <p>This field does not have to be present if false.</p>"},{"location":"image_management/#smp.image_management.ImageState.pending","title":"<code>pending: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>True if image is set for next swap.</p> <p>This field does not have to be present if false.</p>"},{"location":"image_management/#smp.image_management.ImageState.confirmed","title":"<code>confirmed: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>True if image has been confirmed.</p> <p>This field does not have to be present if false.</p>"},{"location":"image_management/#smp.image_management.ImageState.active","title":"<code>active: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>True if image is currently active application</p> <p>This field does not have to be present if false.</p>"},{"location":"image_management/#smp.image_management.ImageState.permanent","title":"<code>permanent: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>True if image is to stay in primary slot after the next boot.</p> <p>This does not have to be present if false.</p>"},{"location":"image_management/#smp.image_management.ImageState.cast_bytes","title":"<code>cast_bytes(v: bytes | None, _: ValidationInfo) -&gt; HashBytes | None</code>  <code>classmethod</code>","text":"Source code in <code>smp\\image_management.py</code> <pre><code>@field_validator(\"hash\")\n@classmethod\ndef cast_bytes(cls, v: bytes | None, _: ValidationInfo) -&gt; HashBytes | None:\n    if v is None:\n        return None\n    return HashBytes(v)\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageStatesReadRequest","title":"<code>ImageStatesReadRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Obtain list of images with their current state.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageStatesReadRequest(message.ReadRequest):\n    \"\"\"Obtain list of images with their current state.\"\"\"\n\n    _GROUP_ID = header.GroupId.IMAGE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.ImageManagement.STATE\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageStatesReadResponse","title":"<code>ImageStatesReadResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Response to an image state request.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageStatesReadResponse(message.ReadResponse):\n    \"\"\"Response to an image state request.\"\"\"\n\n    _GROUP_ID = header.GroupId.IMAGE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.ImageManagement.STATE\n\n    images: List[ImageState]\n    \"\"\"List of images with their current state.\"\"\"\n    splitStatus: int | None = None\n    \"\"\"States whether loader of split image is compatible with application part.\n\n    This is unused by Zephyr.\n    \"\"\"\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageStatesReadResponse.images","title":"<code>images: List[ImageState]</code>  <code>instance-attribute</code>","text":"<p>List of images with their current state.</p>"},{"location":"image_management/#smp.image_management.ImageStatesReadResponse.splitStatus","title":"<code>splitStatus: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>States whether loader of split image is compatible with application part.</p> <p>This is unused by Zephyr.</p>"},{"location":"image_management/#smp.image_management.ImageStatesWriteRequest","title":"<code>ImageStatesWriteRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Set the state of an image.</p> <p>If \u201cconfirm\u201d is false or not provided, an image with the \u201chash\u201d will be set for test, which means that it will not be marked as permanent and upon hard reset the previous application will be restored to the primary slot. In case when \u201cconfirm\u201d is true, the \u201chash\u201d is optional as the currently running application will be assumed as target for confirmation.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageStatesWriteRequest(message.WriteRequest):\n    \"\"\"Set the state of an image.\n\n    If \u201cconfirm\u201d is false or not provided, an image with the \u201chash\u201d will be set\n    for test, which means that it will not be marked as permanent and upon hard\n    reset the previous application will be restored to the primary slot. In case\n    when \u201cconfirm\u201d is true, the \u201chash\u201d is optional as the currently running\n    application will be assumed as target for confirmation.\n    \"\"\"\n\n    _GROUP_ID = header.GroupId.IMAGE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.ImageManagement.STATE\n\n    hash: bytes | None = None\n    \"\"\"SHA256 hash of the image header and body.\"\"\"\n    confirm: bool = False\n    \"\"\"Confirm the image given by hash.\n\n    CAUTION: it is dangerous to confirm the image before it has been booted!\n\n    Setting this to true will mark the image as confirmed before it has been\n    booted, which can brick the device.  Zephyr provides hooks for confirming\n    the image from within the application, so this is not necessary for normal\n    operation.\n    \"\"\"\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageStatesWriteRequest.hash","title":"<code>hash: bytes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SHA256 hash of the image header and body.</p>"},{"location":"image_management/#smp.image_management.ImageStatesWriteRequest.confirm","title":"<code>confirm: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Confirm the image given by hash.</p> <p>CAUTION: it is dangerous to confirm the image before it has been booted!</p> <p>Setting this to true will mark the image as confirmed before it has been booted, which can brick the device.  Zephyr provides hooks for confirming the image from within the application, so this is not necessary for normal operation.</p>"},{"location":"image_management/#smp.image_management.ImageStatesWriteResponse","title":"<code>ImageStatesWriteResponse</code>","text":"<p>               Bases: <code>ImageStatesReadResponse</code></p> <p>Success response to an image state write request.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageStatesWriteResponse(ImageStatesReadResponse):\n    \"\"\"Success response to an image state write request.\"\"\"\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageUploadWriteRequest","title":"<code>ImageUploadWriteRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Upload an image to the device.</p> <p>The image is uploaded in chunks, with each chunk being sent in a separate request. The first request must include the image's length and image number.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageUploadWriteRequest(message.WriteRequest):\n    \"\"\"Upload an image to the device.\n\n    The image is uploaded in chunks, with each chunk being sent in a separate\n    request. The first request must include the image's length and image number.\n    \"\"\"\n\n    _GROUP_ID = header.GroupId.IMAGE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.ImageManagement.UPLOAD\n\n    off: int\n    \"\"\"The offset of the data chunk in this request.\"\"\"\n    data: bytes\n    \"\"\"The data chunk to write.\"\"\"\n    image: int | None = None\n    \"\"\"Image number.\n\n    It does not have to appear in request at all, in which case it is assumed to\n    be 0. Should only be present when `off` is 0.\n    \"\"\"\n    len: int | None = None\n    \"\"\"The length of the image.\n\n    Required when `off` is 0, otherwise ignored.\n    \"\"\"\n    sha: bytes | None = None\n    \"\"\"SHA256 hash of the image.\n\n    This is used to identify an upload session (e.g. to allow to continue\n    a broken session), and for image verification purposes. This must be a full\n    SHA256 hash of the whole image being uploaded, or not included if the hash\n    is not available (in which case, upload session continuation and image\n    verification functionality will be unavailable). Should only be present when\n    \u201coff\u201d is 0.\n    \"\"\"\n    upgrade: bool | None = None\n    \"\"\"Optional flag that states that only upgrade should be allowed.\n\n    If the version of uploaded software is not higher then already on a device,\n    the image upload will be rejected. Zephyr compares major, minor and\n    revision (x.y.z) by default unless `CONFIG_MCUMGR_GRP_IMG_VERSION_CMP_USE_BUILD_NUMBER`\n    is set, whereby it will compare build numbers too. Should only be present\n    when \u201coff\u201d is 0.\n    \"\"\"\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageUploadWriteRequest.off","title":"<code>off: int</code>  <code>instance-attribute</code>","text":"<p>The offset of the data chunk in this request.</p>"},{"location":"image_management/#smp.image_management.ImageUploadWriteRequest.data","title":"<code>data: bytes</code>  <code>instance-attribute</code>","text":"<p>The data chunk to write.</p>"},{"location":"image_management/#smp.image_management.ImageUploadWriteRequest.image","title":"<code>image: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Image number.</p> <p>It does not have to appear in request at all, in which case it is assumed to be 0. Should only be present when <code>off</code> is 0.</p>"},{"location":"image_management/#smp.image_management.ImageUploadWriteRequest.len","title":"<code>len: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The length of the image.</p> <p>Required when <code>off</code> is 0, otherwise ignored.</p>"},{"location":"image_management/#smp.image_management.ImageUploadWriteRequest.sha","title":"<code>sha: bytes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SHA256 hash of the image.</p> <p>This is used to identify an upload session (e.g. to allow to continue a broken session), and for image verification purposes. This must be a full SHA256 hash of the whole image being uploaded, or not included if the hash is not available (in which case, upload session continuation and image verification functionality will be unavailable). Should only be present when \u201coff\u201d is 0.</p>"},{"location":"image_management/#smp.image_management.ImageUploadWriteRequest.upgrade","title":"<code>upgrade: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional flag that states that only upgrade should be allowed.</p> <p>If the version of uploaded software is not higher then already on a device, the image upload will be rejected. Zephyr compares major, minor and revision (x.y.z) by default unless <code>CONFIG_MCUMGR_GRP_IMG_VERSION_CMP_USE_BUILD_NUMBER</code> is set, whereby it will compare build numbers too. Should only be present when \u201coff\u201d is 0.</p>"},{"location":"image_management/#smp.image_management.ImageUploadWriteResponse","title":"<code>ImageUploadWriteResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to an image upload request.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageUploadWriteResponse(message.WriteResponse):\n    \"\"\"Success response to an image upload request.\"\"\"\n\n    _GROUP_ID = header.GroupId.IMAGE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.ImageManagement.UPLOAD\n\n    off: int | None = None\n    \"\"\"The portion of the upload that has been completed, in 8-bit bytes.\n\n    This is the offset of the next byte to be written. If the offset is equal to\n    the length of the image, the upload is complete.\n    \"\"\"\n\n    match: bool | None = None\n    \"\"\"Indicates if the uploaded data successfully matches the provided SHA256.\n\n    Only sent in the final packet if CONFIG_IMG_ENABLE_IMAGE_CHECK is enabled.\n    \"\"\"\n\n    rc: int | None = None\n    \"\"\"Legacy field that contains a return code; possibly `MGMT_ERR`.\n\n    This field may be present on old SMP server implementations or new SMP\n    server implementations that have set\n    `CONFIG_MCUMGR_SMP_LEGACY_RC_BEHAVIOUR=y` for backwards compatibility with\n    old SMP clients.\n\n    Note that we are not validating this field because we don't necessarily\n    trust the server to send us valid values. If this value is present, then it\n    indicates use of an SMP server that is out of spec and interpretation of the\n    value should be done with reference to that server's source code, rather\n    that the SMP specification.\n\n    Zephyr source code reference: https://github.com/zephyrproject-rtos/zephyr/blob/91a1e706535b2f99433280513c5bc66dfb918506/subsys/mgmt/mcumgr/grp/img_mgmt/src/img_mgmt.c#L397-L400\n    \"\"\"  # noqa: E501\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageUploadWriteResponse.off","title":"<code>off: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The portion of the upload that has been completed, in 8-bit bytes.</p> <p>This is the offset of the next byte to be written. If the offset is equal to the length of the image, the upload is complete.</p>"},{"location":"image_management/#smp.image_management.ImageUploadWriteResponse.match","title":"<code>match: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates if the uploaded data successfully matches the provided SHA256.</p> <p>Only sent in the final packet if CONFIG_IMG_ENABLE_IMAGE_CHECK is enabled.</p>"},{"location":"image_management/#smp.image_management.ImageUploadWriteResponse.rc","title":"<code>rc: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Legacy field that contains a return code; possibly <code>MGMT_ERR</code>.</p> <p>This field may be present on old SMP server implementations or new SMP server implementations that have set <code>CONFIG_MCUMGR_SMP_LEGACY_RC_BEHAVIOUR=y</code> for backwards compatibility with old SMP clients.</p> <p>Note that we are not validating this field because we don't necessarily trust the server to send us valid values. If this value is present, then it indicates use of an SMP server that is out of spec and interpretation of the value should be done with reference to that server's source code, rather that the SMP specification.</p> <p>Zephyr source code reference: https://github.com/zephyrproject-rtos/zephyr/blob/91a1e706535b2f99433280513c5bc66dfb918506/subsys/mgmt/mcumgr/grp/img_mgmt/src/img_mgmt.c#L397-L400</p>"},{"location":"image_management/#smp.image_management.ImageEraseRequest","title":"<code>ImageEraseRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Erase an image from a slot.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageEraseRequest(message.WriteRequest):\n    \"\"\"Erase an image from a slot.\"\"\"\n\n    _GROUP_ID = header.GroupId.IMAGE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.ImageManagement.ERASE\n\n    slot: int | None = None\n    \"\"\"The slot to erase. If not provided, slot 1 will be erased.\"\"\"\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageEraseRequest.slot","title":"<code>slot: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The slot to erase. If not provided, slot 1 will be erased.</p>"},{"location":"image_management/#smp.image_management.ImageEraseResponse","title":"<code>ImageEraseResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to an image erase request.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageEraseResponse(message.WriteResponse):\n    \"\"\"Success response to an image erase request.\"\"\"\n\n    _GROUP_ID = header.GroupId.IMAGE_MANAGEMENT\n    _COMMAND_ID = header.CommandId.ImageManagement.ERASE\n</code></pre>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR","title":"<code>IMG_MGMT_ERR</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Image management error codes.</p> Source code in <code>smp\\image_management.py</code> <pre><code>@unique\nclass IMG_MGMT_ERR(IntEnum):\n    \"\"\"Image management error codes.\"\"\"\n\n    OK = 0\n    \"\"\"No error, this is implied if there is no ret value in the response\"\"\"\n\n    UNKNOWN = 1\n    \"\"\"Unknown error occurred.\"\"\"\n\n    FLASH_CONFIG_QUERY_FAIL = 2\n    \"\"\"Failed to query flash area configuration.\"\"\"\n\n    NO_IMAGE = 3\n    \"\"\"There is no image in the slot.\"\"\"\n\n    NO_TLVS = 4\n    \"\"\"The image in the slot has no TLVs (tag, length, value).\"\"\"\n\n    INVALID_TLV = 5\n    \"\"\"The image in the slot has an invalid TLV type and/or length.\"\"\"\n\n    TLV_MULTIPLE_HASHES_FOUND = 6\n    \"\"\"The image in the slot has multiple hash TLVs, which is invalid.\"\"\"\n\n    TLV_INVALID_SIZE = 7\n    \"\"\"The image in the slot has an invalid TLV size.\"\"\"\n\n    HASH_NOT_FOUND = 8\n    \"\"\"The image in the slot does not have a hash TLV, which is required.\"\"\"\n\n    NO_FREE_SLOT = 9\n    \"\"\"There is no free slot to place the image.\"\"\"\n\n    FLASH_OPEN_FAILED = 10\n    \"\"\"Flash area opening failed.\"\"\"\n\n    FLASH_READ_FAILED = 11\n    \"\"\"Flash area reading failed.\"\"\"\n\n    FLASH_WRITE_FAILED = 12\n    \"\"\"Flash area writing failed.\"\"\"\n\n    FLASH_ERASE_FAILED = 13\n    \"\"\"Flash area erase failed.\"\"\"\n\n    INVALID_SLOT = 14\n    \"\"\"The provided slot is not valid.\"\"\"\n\n    NO_FREE_MEMORY = 15\n    \"\"\"Insufficient heap memory (malloc failed).\"\"\"\n\n    FLASH_CONTEXT_ALREADY_SET = 16\n    \"\"\"The flash context is already set.\"\"\"\n\n    FLASH_CONTEXT_NOT_SET = 17\n    \"\"\"The flash context is not set.\"\"\"\n\n    FLASH_AREA_DEVICE_NULL = 18\n    \"\"\"The device for the flash area is NULL.\"\"\"\n\n    INVALID_PAGE_OFFSET = 19\n    \"\"\"The offset for a page number is invalid.\"\"\"\n\n    INVALID_OFFSET = 20\n    \"\"\"The offset parameter was not provided and is required.\"\"\"\n\n    INVALID_LENGTH = 21\n    \"\"\"The length parameter was not provided and is required.\"\"\"\n\n    INVALID_IMAGE_HEADER = 22\n    \"\"\"The image length is smaller than the size of an image header.\"\"\"\n\n    INVALID_IMAGE_HEADER_MAGIC = 23\n    \"\"\"The image header magic value does not match the expected value.\"\"\"\n\n    INVALID_HASH = 24\n    \"\"\"The hash parameter provided is not valid.\"\"\"\n\n    INVALID_FLASH_ADDRESS = 25\n    \"\"\"The image load address does not match the address of the flash area.\"\"\"\n\n    VERSION_GET_FAILED = 26\n    \"\"\"Failed to get version of currently running application.\"\"\"\n\n    CURRENT_VERSION_IS_NEWER = 27\n    \"\"\"The currently running application is newer than the version being uploaded.\"\"\"\n\n    IMAGE_ALREADY_PENDING = 28\n    \"\"\"There is already an image operating pending.\"\"\"\n\n    INVALID_IMAGE_VECTOR_TABLE = 29\n    \"\"\"The image vector table is invalid.\"\"\"\n\n    INVALID_IMAGE_TOO_LARGE = 30\n    \"\"\"The image it too large to fit.\"\"\"\n\n    INVALID_IMAGE_DATA_OVERRUN = 31\n    \"\"\"The amount of data sent is larger than the provided image size.\"\"\"\n\n    IMAGE_CONFIRMATION_DENIED = 32\n    \"\"\"Confirmation of image has been denied\"\"\"\n\n    IMAGE_SETTING_TEST_TO_ACTIVE_DENIED = 33\n    \"\"\"Setting test to active slot is not allowed\"\"\"\n</code></pre>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No error, this is implied if there is no ret value in the response</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown error occurred.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.FLASH_CONFIG_QUERY_FAIL","title":"<code>FLASH_CONFIG_QUERY_FAIL = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Failed to query flash area configuration.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.NO_IMAGE","title":"<code>NO_IMAGE = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>There is no image in the slot.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.NO_TLVS","title":"<code>NO_TLVS = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image in the slot has no TLVs (tag, length, value).</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_TLV","title":"<code>INVALID_TLV = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image in the slot has an invalid TLV type and/or length.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.TLV_MULTIPLE_HASHES_FOUND","title":"<code>TLV_MULTIPLE_HASHES_FOUND = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image in the slot has multiple hash TLVs, which is invalid.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.TLV_INVALID_SIZE","title":"<code>TLV_INVALID_SIZE = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image in the slot has an invalid TLV size.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.HASH_NOT_FOUND","title":"<code>HASH_NOT_FOUND = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image in the slot does not have a hash TLV, which is required.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.NO_FREE_SLOT","title":"<code>NO_FREE_SLOT = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>There is no free slot to place the image.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.FLASH_OPEN_FAILED","title":"<code>FLASH_OPEN_FAILED = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Flash area opening failed.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.FLASH_READ_FAILED","title":"<code>FLASH_READ_FAILED = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Flash area reading failed.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.FLASH_WRITE_FAILED","title":"<code>FLASH_WRITE_FAILED = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Flash area writing failed.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.FLASH_ERASE_FAILED","title":"<code>FLASH_ERASE_FAILED = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Flash area erase failed.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_SLOT","title":"<code>INVALID_SLOT = 14</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided slot is not valid.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.NO_FREE_MEMORY","title":"<code>NO_FREE_MEMORY = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Insufficient heap memory (malloc failed).</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.FLASH_CONTEXT_ALREADY_SET","title":"<code>FLASH_CONTEXT_ALREADY_SET = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The flash context is already set.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.FLASH_CONTEXT_NOT_SET","title":"<code>FLASH_CONTEXT_NOT_SET = 17</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The flash context is not set.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.FLASH_AREA_DEVICE_NULL","title":"<code>FLASH_AREA_DEVICE_NULL = 18</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The device for the flash area is NULL.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_PAGE_OFFSET","title":"<code>INVALID_PAGE_OFFSET = 19</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The offset for a page number is invalid.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_OFFSET","title":"<code>INVALID_OFFSET = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The offset parameter was not provided and is required.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_LENGTH","title":"<code>INVALID_LENGTH = 21</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The length parameter was not provided and is required.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_IMAGE_HEADER","title":"<code>INVALID_IMAGE_HEADER = 22</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image length is smaller than the size of an image header.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_IMAGE_HEADER_MAGIC","title":"<code>INVALID_IMAGE_HEADER_MAGIC = 23</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image header magic value does not match the expected value.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_HASH","title":"<code>INVALID_HASH = 24</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The hash parameter provided is not valid.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_FLASH_ADDRESS","title":"<code>INVALID_FLASH_ADDRESS = 25</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image load address does not match the address of the flash area.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.VERSION_GET_FAILED","title":"<code>VERSION_GET_FAILED = 26</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Failed to get version of currently running application.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.CURRENT_VERSION_IS_NEWER","title":"<code>CURRENT_VERSION_IS_NEWER = 27</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The currently running application is newer than the version being uploaded.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.IMAGE_ALREADY_PENDING","title":"<code>IMAGE_ALREADY_PENDING = 28</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>There is already an image operating pending.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_IMAGE_VECTOR_TABLE","title":"<code>INVALID_IMAGE_VECTOR_TABLE = 29</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image vector table is invalid.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_IMAGE_TOO_LARGE","title":"<code>INVALID_IMAGE_TOO_LARGE = 30</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image it too large to fit.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.INVALID_IMAGE_DATA_OVERRUN","title":"<code>INVALID_IMAGE_DATA_OVERRUN = 31</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The amount of data sent is larger than the provided image size.</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.IMAGE_CONFIRMATION_DENIED","title":"<code>IMAGE_CONFIRMATION_DENIED = 32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Confirmation of image has been denied</p>"},{"location":"image_management/#smp.image_management.IMG_MGMT_ERR.IMAGE_SETTING_TEST_TO_ACTIVE_DENIED","title":"<code>IMAGE_SETTING_TEST_TO_ACTIVE_DENIED = 33</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Setting test to active slot is not allowed</p>"},{"location":"image_management/#smp.image_management.ImageManagementErrorV1","title":"<code>ImageManagementErrorV1</code>","text":"<p>               Bases: <code>ErrorV1</code></p> <p>Image Management error response.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageManagementErrorV1(error.ErrorV1):\n    \"\"\"Image Management error response.\"\"\"\n\n    _GROUP_ID = header.GroupId.IMAGE_MANAGEMENT\n</code></pre>"},{"location":"image_management/#smp.image_management.ImageManagementErrorV2","title":"<code>ImageManagementErrorV2</code>","text":"<p>               Bases: <code>ErrorV2[IMG_MGMT_ERR]</code></p> <p>Image Management error response.</p> Source code in <code>smp\\image_management.py</code> <pre><code>class ImageManagementErrorV2(error.ErrorV2[IMG_MGMT_ERR]):\n    \"\"\"Image Management error response.\"\"\"\n\n    _GROUP_ID = header.GroupId.IMAGE_MANAGEMENT\n</code></pre>"},{"location":"message/","title":"De/serialization and Validation","text":"<p>The Simple Management Protocol (SMP) Message base class.</p>"},{"location":"message/#smp.message.T","title":"<code>T = TypeVar('T', bound='_MessageBase')</code>  <code>module-attribute</code>","text":""},{"location":"message/#smp.message._counter","title":"<code>_counter = itertools.count()</code>  <code>module-attribute</code>","text":""},{"location":"message/#smp.message.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase","title":"<code>_MessageBase</code>","text":"<p>               Bases: <code>ABC</code>, <code>BaseModel</code></p> <p>The base class for SMP messages.</p> Source code in <code>smp\\message.py</code> <pre><code>class _MessageBase(ABC, BaseModel):\n    \"\"\"The base class for SMP messages.\"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", frozen=True)\n\n    _OP: ClassVar[smpheader.OP]\n    _FLAGS: ClassVar[smpheader.Flag] = smpheader.Flag(0)\n    _GROUP_ID: ClassVar[smpheader.GroupId | smpheader.UserGroupId | smpheader.AnyGroupId]\n    _COMMAND_ID: ClassVar[\n        smpheader.AnyCommandId\n        | smpheader.CommandId.ImageManagement\n        | smpheader.CommandId.OSManagement\n        | smpheader.CommandId.ShellManagement\n        | smpheader.CommandId.Intercreate\n        | smpheader.CommandId.FileManagement\n    ]\n\n    # This is is a dummy header that will be replaced in model_post_init\n    header: smpheader.Header = None  # type: ignore\n    version: smpheader.Version = smpheader.Version.V2\n    sequence: int = None  # type: ignore\n    smp_data: bytes = None  # type: ignore\n\n    def __bytes__(self) -&gt; bytes:\n        return self.smp_data\n\n    @property\n    def BYTES(self) -&gt; bytes:\n        return self.smp_data\n\n    @classmethod\n    def loads(cls: Type[T], data: bytes) -&gt; T:\n        \"\"\"Deserialize the SMP message.\"\"\"\n        message = cls(\n            header=smpheader.Header.loads(data[: smpheader.Header.SIZE]),\n            **cast(dict, cbor2.loads(data[smpheader.Header.SIZE :])),\n            smp_data=data,\n        )\n        if message.header is None:  # pragma: no cover\n            raise ValueError\n        if message.header.group_id != cls._GROUP_ID:  # pragma: no cover\n            raise SMPMismatchedGroupId(\n                f\"{cls.__name__} has {cls._GROUP_ID}, header has {message.header.group_id}\"\n            )\n        return message\n\n    @classmethod\n    def load(cls: Type[T], header: smpheader.Header, data: dict) -&gt; T:\n        \"\"\"Load an SMP header and CBOR dict.\"\"\"\n        if header.group_id != cls._GROUP_ID:  # pragma: no cover\n            raise SMPMismatchedGroupId(\n                f\"{cls.__name__} has {cls._GROUP_ID}, header has {header.group_id}\"\n            )\n        return cls(header=header, **data)\n\n    def model_post_init(self, _: None) -&gt; None:\n        data_bytes = cbor2.dumps(\n            self.model_dump(\n                exclude_unset=True,\n                exclude={'header', 'version', 'sequence', 'smp_data'},\n                exclude_none=True,\n            ),\n            canonical=True,\n        )\n        if self.header is None:  # create the header\n            object.__setattr__(\n                self,\n                'header',\n                smpheader.Header(\n                    op=self._OP,\n                    version=self.version,\n                    flags=smpheader.Flag(self._FLAGS),\n                    length=len(data_bytes),\n                    group_id=self._GROUP_ID,\n                    sequence=next(_counter) % 0xFF if self.sequence is None else self.sequence,\n                    command_id=self._COMMAND_ID,\n                ),\n            )\n            object.__setattr__(self, 'sequence', self.header.sequence)\n        else:  # validate the header and update version &amp; sequence\n            if self.smp_data is None and self.header.length != len(data_bytes):\n                raise SMPMalformed(\n                    f\"header.length {self.header.length} != len(data_bytes) {len(data_bytes)}\"\n                )\n            if self.sequence is not None:  # pragma: no cover\n                raise ValueError(\n                    f\"{self.sequence=} {self.header.sequence=} \"\n                    \"Do not use the sequence attribute when the header is provided.\"\n                )\n            object.__setattr__(self, 'sequence', self.header.sequence)\n            if self.version != self.header.version:\n                logger.warning(\n                    f\"Overriding {self.version=} with {self.header.version=} \"\n                    \"from the provided header.\"\n                )\n            object.__setattr__(self, 'version', self.header.version)\n        if self.smp_data is None:\n            object.__setattr__(self, 'smp_data', bytes(self.header) + data_bytes)\n</code></pre>"},{"location":"message/#smp.message._MessageBase.model_config","title":"<code>model_config = ConfigDict(extra='forbid', frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase._OP","title":"<code>_OP: smpheader.OP</code>  <code>class-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase._FLAGS","title":"<code>_FLAGS: smpheader.Flag = smpheader.Flag(0)</code>  <code>class-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase._GROUP_ID","title":"<code>_GROUP_ID: smpheader.GroupId | smpheader.UserGroupId | smpheader.AnyGroupId</code>  <code>class-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase._COMMAND_ID","title":"<code>_COMMAND_ID: smpheader.AnyCommandId | smpheader.CommandId.ImageManagement | smpheader.CommandId.OSManagement | smpheader.CommandId.ShellManagement | smpheader.CommandId.Intercreate | smpheader.CommandId.FileManagement</code>  <code>class-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase.header","title":"<code>header: smpheader.Header = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase.version","title":"<code>version: smpheader.Version = smpheader.Version.V2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase.sequence","title":"<code>sequence: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase.smp_data","title":"<code>smp_data: bytes = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message._MessageBase.BYTES","title":"<code>BYTES: bytes</code>  <code>property</code>","text":""},{"location":"message/#smp.message._MessageBase.__bytes__","title":"<code>__bytes__() -&gt; bytes</code>","text":"Source code in <code>smp\\message.py</code> <pre><code>def __bytes__(self) -&gt; bytes:\n    return self.smp_data\n</code></pre>"},{"location":"message/#smp.message._MessageBase.loads","title":"<code>loads(data: bytes) -&gt; T</code>  <code>classmethod</code>","text":"<p>Deserialize the SMP message.</p> Source code in <code>smp\\message.py</code> <pre><code>@classmethod\ndef loads(cls: Type[T], data: bytes) -&gt; T:\n    \"\"\"Deserialize the SMP message.\"\"\"\n    message = cls(\n        header=smpheader.Header.loads(data[: smpheader.Header.SIZE]),\n        **cast(dict, cbor2.loads(data[smpheader.Header.SIZE :])),\n        smp_data=data,\n    )\n    if message.header is None:  # pragma: no cover\n        raise ValueError\n    if message.header.group_id != cls._GROUP_ID:  # pragma: no cover\n        raise SMPMismatchedGroupId(\n            f\"{cls.__name__} has {cls._GROUP_ID}, header has {message.header.group_id}\"\n        )\n    return message\n</code></pre>"},{"location":"message/#smp.message._MessageBase.load","title":"<code>load(header: smpheader.Header, data: dict) -&gt; T</code>  <code>classmethod</code>","text":"<p>Load an SMP header and CBOR dict.</p> Source code in <code>smp\\message.py</code> <pre><code>@classmethod\ndef load(cls: Type[T], header: smpheader.Header, data: dict) -&gt; T:\n    \"\"\"Load an SMP header and CBOR dict.\"\"\"\n    if header.group_id != cls._GROUP_ID:  # pragma: no cover\n        raise SMPMismatchedGroupId(\n            f\"{cls.__name__} has {cls._GROUP_ID}, header has {header.group_id}\"\n        )\n    return cls(header=header, **data)\n</code></pre>"},{"location":"message/#smp.message._MessageBase.model_post_init","title":"<code>model_post_init(_: None) -&gt; None</code>","text":"Source code in <code>smp\\message.py</code> <pre><code>def model_post_init(self, _: None) -&gt; None:\n    data_bytes = cbor2.dumps(\n        self.model_dump(\n            exclude_unset=True,\n            exclude={'header', 'version', 'sequence', 'smp_data'},\n            exclude_none=True,\n        ),\n        canonical=True,\n    )\n    if self.header is None:  # create the header\n        object.__setattr__(\n            self,\n            'header',\n            smpheader.Header(\n                op=self._OP,\n                version=self.version,\n                flags=smpheader.Flag(self._FLAGS),\n                length=len(data_bytes),\n                group_id=self._GROUP_ID,\n                sequence=next(_counter) % 0xFF if self.sequence is None else self.sequence,\n                command_id=self._COMMAND_ID,\n            ),\n        )\n        object.__setattr__(self, 'sequence', self.header.sequence)\n    else:  # validate the header and update version &amp; sequence\n        if self.smp_data is None and self.header.length != len(data_bytes):\n            raise SMPMalformed(\n                f\"header.length {self.header.length} != len(data_bytes) {len(data_bytes)}\"\n            )\n        if self.sequence is not None:  # pragma: no cover\n            raise ValueError(\n                f\"{self.sequence=} {self.header.sequence=} \"\n                \"Do not use the sequence attribute when the header is provided.\"\n            )\n        object.__setattr__(self, 'sequence', self.header.sequence)\n        if self.version != self.header.version:\n            logger.warning(\n                f\"Overriding {self.version=} with {self.header.version=} \"\n                \"from the provided header.\"\n            )\n        object.__setattr__(self, 'version', self.header.version)\n    if self.smp_data is None:\n        object.__setattr__(self, 'smp_data', bytes(self.header) + data_bytes)\n</code></pre>"},{"location":"message/#smp.message.Request","title":"<code>Request</code>","text":"<p>               Bases: <code>_MessageBase</code>, <code>ABC</code></p> <p>Base class for SMP Requests.</p> Source code in <code>smp\\message.py</code> <pre><code>class Request(_MessageBase, ABC):\n    \"\"\"Base class for SMP Requests.\"\"\"\n</code></pre>"},{"location":"message/#smp.message.ResponseType","title":"<code>ResponseType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>An SMP <code>Response</code> to an SMP <code>Request</code> must be <code>SUCCESS</code>, <code>ERROR_V1</code>, or <code>ERROR_V2</code>.</p> Source code in <code>smp\\message.py</code> <pre><code>@unique\nclass ResponseType(IntEnum):\n    \"\"\"An SMP `Response` to an SMP `Request` must be `SUCCESS`, `ERROR_V1`, or `ERROR_V2`.\"\"\"\n\n    SUCCESS = 0\n    ERROR_V1 = 1\n    ERROR_V2 = 2\n</code></pre>"},{"location":"message/#smp.message.ResponseType.SUCCESS","title":"<code>SUCCESS = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message.ResponseType.ERROR_V1","title":"<code>ERROR_V1 = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message.ResponseType.ERROR_V2","title":"<code>ERROR_V2 = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>_MessageBase</code>, <code>ABC</code></p> <p>Base class for SMP Responses.</p> Source code in <code>smp\\message.py</code> <pre><code>class Response(_MessageBase, ABC):\n    \"\"\"Base class for SMP Responses.\"\"\"\n\n    RESPONSE_TYPE: ClassVar[ResponseType]\n</code></pre>"},{"location":"message/#smp.message.Response.RESPONSE_TYPE","title":"<code>RESPONSE_TYPE: ResponseType</code>  <code>class-attribute</code>","text":""},{"location":"message/#smp.message.ReadRequest","title":"<code>ReadRequest</code>","text":"<p>               Bases: <code>Request</code>, <code>ABC</code></p> <p>A read request from an SMP client to an SMP server.</p> Source code in <code>smp\\message.py</code> <pre><code>class ReadRequest(Request, ABC):\n    \"\"\"A read request from an SMP client to an SMP server.\"\"\"\n\n    _OP = smpheader.OP.READ\n</code></pre>"},{"location":"message/#smp.message.ReadRequest._OP","title":"<code>_OP = smpheader.OP.READ</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message.ReadResponse","title":"<code>ReadResponse</code>","text":"<p>               Bases: <code>Response</code>, <code>ABC</code></p> <p>A response from an SMP server to an SMP client read request.</p> Source code in <code>smp\\message.py</code> <pre><code>class ReadResponse(Response, ABC):\n    \"\"\"A response from an SMP server to an SMP client read request.\"\"\"\n\n    RESPONSE_TYPE = ResponseType.SUCCESS\n    _OP = smpheader.OP.READ_RSP\n</code></pre>"},{"location":"message/#smp.message.ReadResponse.RESPONSE_TYPE","title":"<code>RESPONSE_TYPE = ResponseType.SUCCESS</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message.ReadResponse._OP","title":"<code>_OP = smpheader.OP.READ_RSP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message.WriteRequest","title":"<code>WriteRequest</code>","text":"<p>               Bases: <code>Request</code>, <code>ABC</code></p> <p>A write request from an SMP client to an SMP server.</p> Source code in <code>smp\\message.py</code> <pre><code>class WriteRequest(Request, ABC):\n    \"\"\"A write request from an SMP client to an SMP server.\"\"\"\n\n    _OP = smpheader.OP.WRITE\n</code></pre>"},{"location":"message/#smp.message.WriteRequest._OP","title":"<code>_OP = smpheader.OP.WRITE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message.WriteResponse","title":"<code>WriteResponse</code>","text":"<p>               Bases: <code>Response</code>, <code>ABC</code></p> <p>A response from an SMP server to an SMP client write request.</p> Source code in <code>smp\\message.py</code> <pre><code>class WriteResponse(Response, ABC):\n    \"\"\"A response from an SMP server to an SMP client write request.\"\"\"\n\n    RESPONSE_TYPE = ResponseType.SUCCESS\n    _OP = smpheader.OP.WRITE_RSP\n</code></pre>"},{"location":"message/#smp.message.WriteResponse.RESPONSE_TYPE","title":"<code>RESPONSE_TYPE = ResponseType.SUCCESS</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"message/#smp.message.WriteResponse._OP","title":"<code>_OP = smpheader.OP.WRITE_RSP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/","title":"OS Management","text":"<p>The Simple Management Protocol (SMP) OS Management group.</p>"},{"location":"os_management/#smp.os_management.EchoWriteRequest","title":"<code>EchoWriteRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Echo back the provided string.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class EchoWriteRequest(message.WriteRequest):\n    \"\"\"Echo back the provided string.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.ECHO\n\n    d: str\n    \"\"\"String to echo.\"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.EchoWriteRequest.d","title":"<code>d: str</code>  <code>instance-attribute</code>","text":"<p>String to echo.</p>"},{"location":"os_management/#smp.os_management.EchoWriteResponse","title":"<code>EchoWriteResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to an echo request.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class EchoWriteResponse(message.WriteResponse):\n    \"\"\"Success response to an echo request.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.ECHO\n\n    r: str\n    \"\"\"Echoed string.\"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.EchoWriteResponse.r","title":"<code>r: str</code>  <code>instance-attribute</code>","text":"<p>Echoed string.</p>"},{"location":"os_management/#smp.os_management.ResetWriteRequest","title":"<code>ResetWriteRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Performs reset of system.</p> <p>The device should issue response before resetting so that the SMP client could receive information that the command has been accepted. By default, this command is accepted in all conditions, however if the <code>CONFIG_MCUMGR_GRP_OS_RESET_HOOK</code> is enabled and an application registers a callback, the callback will be called when this command is issued and can be used to perform any necessary tidy operations prior to the module rebooting, or to reject the reset request outright altogether with an error response.</p> <p>For details on this functionality, see callbacks.  # noqa: E501</p> Source code in <code>smp\\os_management.py</code> <pre><code>class ResetWriteRequest(message.WriteRequest):\n    \"\"\"Performs reset of system.\n\n    The device should issue response before resetting so that the SMP client\n    could receive information that the command has been accepted. By default,\n    this command is accepted in all conditions, however if the\n    `CONFIG_MCUMGR_GRP_OS_RESET_HOOK` is enabled and an application registers a\n    callback, the callback will be called when this command is issued and can be\n    used to perform any necessary tidy operations prior to the module rebooting,\n    or to reject the reset request outright altogether with an error response.\n\n    For details on this functionality, see [callbacks](https://docs.zephyrproject.org/latest/services/device_mgmt/mcumgr_callbacks.html#mcumgr-callbacks).  # noqa: E501\n    \"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.RESET\n\n    force: Literal[0, 1] | None = None\n    \"\"\"Force reset.\n\n    Normally the command sends an empty CBOR map as data, but if a previous\n    reset attempt has responded with \u201crc\u201d equal to MGMT_ERR_EBUSY then the\n    following map may be sent to force a reset\n    \"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.ResetWriteRequest.force","title":"<code>force: Literal[0, 1] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Force reset.</p> <p>Normally the command sends an empty CBOR map as data, but if a previous reset attempt has responded with \u201crc\u201d equal to MGMT_ERR_EBUSY then the following map may be sent to force a reset</p>"},{"location":"os_management/#smp.os_management.ResetWriteResponse","title":"<code>ResetWriteResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to a reset request.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class ResetWriteResponse(message.WriteResponse):\n    \"\"\"Success response to a reset request.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.RESET\n</code></pre>"},{"location":"os_management/#smp.os_management.TaskStatisticsReadRequest","title":"<code>TaskStatisticsReadRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Request task statistics.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class TaskStatisticsReadRequest(message.ReadRequest):\n    \"\"\"Request task statistics.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.TASK_STATS\n</code></pre>"},{"location":"os_management/#smp.os_management.TaskStatistics","title":"<code>TaskStatistics</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Task statistics.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class TaskStatistics(BaseModel):\n    \"\"\"Task statistics.\"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", frozen=True)\n\n    prio: int\n    \"\"\"Task priority.\"\"\"\n    tid: int\n    \"\"\"Numeric task ID.\"\"\"\n    state: int\n    \"\"\"Numeric task state.\"\"\"\n    stkuse: int\n    \"\"\"Stack usage.\n\n    The unit is system dependent and in case of Zephyr this is number of 4 byte words.\n    \"\"\"\n    stksize: int\n    \"\"\"Stack size.\n\n    The unit is system dependent and in case of Zephyr this is number of 4 byte words.\n    \"\"\"\n    cswcnt: int\n    \"\"\"Number of context switches.\"\"\"\n    runtime: int\n    \"\"\"Runtime in ticks.\"\"\"\n    last_checkin: int\n    \"\"\"Set to 0 by Zephyr.\"\"\"\n    next_checkin: int\n    \"\"\"Set to 0 by Zephyr.\"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.TaskStatistics.model_config","title":"<code>model_config = ConfigDict(extra='forbid', frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.TaskStatistics.prio","title":"<code>prio: int</code>  <code>instance-attribute</code>","text":"<p>Task priority.</p>"},{"location":"os_management/#smp.os_management.TaskStatistics.tid","title":"<code>tid: int</code>  <code>instance-attribute</code>","text":"<p>Numeric task ID.</p>"},{"location":"os_management/#smp.os_management.TaskStatistics.state","title":"<code>state: int</code>  <code>instance-attribute</code>","text":"<p>Numeric task state.</p>"},{"location":"os_management/#smp.os_management.TaskStatistics.stkuse","title":"<code>stkuse: int</code>  <code>instance-attribute</code>","text":"<p>Stack usage.</p> <p>The unit is system dependent and in case of Zephyr this is number of 4 byte words.</p>"},{"location":"os_management/#smp.os_management.TaskStatistics.stksize","title":"<code>stksize: int</code>  <code>instance-attribute</code>","text":"<p>Stack size.</p> <p>The unit is system dependent and in case of Zephyr this is number of 4 byte words.</p>"},{"location":"os_management/#smp.os_management.TaskStatistics.cswcnt","title":"<code>cswcnt: int</code>  <code>instance-attribute</code>","text":"<p>Number of context switches.</p>"},{"location":"os_management/#smp.os_management.TaskStatistics.runtime","title":"<code>runtime: int</code>  <code>instance-attribute</code>","text":"<p>Runtime in ticks.</p>"},{"location":"os_management/#smp.os_management.TaskStatistics.last_checkin","title":"<code>last_checkin: int</code>  <code>instance-attribute</code>","text":"<p>Set to 0 by Zephyr.</p>"},{"location":"os_management/#smp.os_management.TaskStatistics.next_checkin","title":"<code>next_checkin: int</code>  <code>instance-attribute</code>","text":"<p>Set to 0 by Zephyr.</p>"},{"location":"os_management/#smp.os_management.TaskStatisticsReadResponse","title":"<code>TaskStatisticsReadResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Task statistics response.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class TaskStatisticsReadResponse(message.ReadResponse):\n    \"\"\"Task statistics response.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.TASK_STATS\n\n    tasks: Dict[str, TaskStatistics]\n    \"\"\"Task statistics map.\"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.TaskStatisticsReadResponse.tasks","title":"<code>tasks: Dict[str, TaskStatistics]</code>  <code>instance-attribute</code>","text":"<p>Task statistics map.</p>"},{"location":"os_management/#smp.os_management.MemoryPoolStatisticsReadRequest","title":"<code>MemoryPoolStatisticsReadRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Request memory pool statistics.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class MemoryPoolStatisticsReadRequest(message.ReadRequest):\n    \"\"\"Request memory pool statistics.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.MEMORY_POOL_STATS\n</code></pre>"},{"location":"os_management/#smp.os_management.MemoryPoolStatistics","title":"<code>MemoryPoolStatistics</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Memory pool statistics.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class MemoryPoolStatistics(BaseModel):\n    \"\"\"Memory pool statistics.\"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", frozen=True)\n\n    blksize: int\n    \"\"\"Size of the memory block in the pool.\"\"\"\n    nblks: int\n    \"\"\"Number of memory blocks in the pool.\"\"\"\n    nfree: int\n    \"\"\"Number of free memory blocks in the pool.\"\"\"\n    min: int\n    \"\"\"Lowest number of free blocks the pool reached during run-time.\"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.MemoryPoolStatistics.model_config","title":"<code>model_config = ConfigDict(extra='forbid', frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MemoryPoolStatistics.blksize","title":"<code>blksize: int</code>  <code>instance-attribute</code>","text":"<p>Size of the memory block in the pool.</p>"},{"location":"os_management/#smp.os_management.MemoryPoolStatistics.nblks","title":"<code>nblks: int</code>  <code>instance-attribute</code>","text":"<p>Number of memory blocks in the pool.</p>"},{"location":"os_management/#smp.os_management.MemoryPoolStatistics.nfree","title":"<code>nfree: int</code>  <code>instance-attribute</code>","text":"<p>Number of free memory blocks in the pool.</p>"},{"location":"os_management/#smp.os_management.MemoryPoolStatistics.min","title":"<code>min: int</code>  <code>instance-attribute</code>","text":"<p>Lowest number of free blocks the pool reached during run-time.</p>"},{"location":"os_management/#smp.os_management.MemoryPoolStatisticsReadResponse","title":"<code>MemoryPoolStatisticsReadResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>The memory pools are accessed by name.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class MemoryPoolStatisticsReadResponse(message.ReadResponse):\n    \"\"\"The memory pools are accessed by name.\"\"\"\n\n    model_config = ConfigDict(extra=\"allow\", frozen=True)\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.MEMORY_POOL_STATS\n</code></pre>"},{"location":"os_management/#smp.os_management.MemoryPoolStatisticsReadResponse.model_config","title":"<code>model_config = ConfigDict(extra='allow', frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.DateTimeReadRequest","title":"<code>DateTimeReadRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Request the current date and time.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class DateTimeReadRequest(message.ReadRequest):\n    \"\"\"Request the current date and time.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.DATETIME_STRING\n</code></pre>"},{"location":"os_management/#smp.os_management.DateTimeReadResponse","title":"<code>DateTimeReadResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Response to a date and time request.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class DateTimeReadResponse(message.ReadResponse):\n    \"\"\"Response to a date and time request.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.DATETIME_STRING\n\n    datetime: str\n</code></pre>"},{"location":"os_management/#smp.os_management.DateTimeReadResponse.datetime","title":"<code>datetime: str</code>  <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.DateTimeWriteRequest","title":"<code>DateTimeWriteRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Set the current date and time.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class DateTimeWriteRequest(message.WriteRequest):\n    \"\"\"Set the current date and time.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.DATETIME_STRING\n\n    datetime: str\n</code></pre>"},{"location":"os_management/#smp.os_management.DateTimeWriteRequest.datetime","title":"<code>datetime: str</code>  <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.DateTimeWriteResponse","title":"<code>DateTimeWriteResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to a date and time request.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class DateTimeWriteResponse(message.WriteResponse):\n    \"\"\"Success response to a date and time request.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.DATETIME_STRING\n</code></pre>"},{"location":"os_management/#smp.os_management.MCUMgrParametersReadRequest","title":"<code>MCUMgrParametersReadRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Request MCU Manager parameters.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class MCUMgrParametersReadRequest(message.ReadRequest):\n    \"\"\"Request MCU Manager parameters.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.MCUMGR_PARAMETERS\n</code></pre>"},{"location":"os_management/#smp.os_management.MCUMgrParametersReadResponse","title":"<code>MCUMgrParametersReadResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Success response to a MCU Manager parameters request.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class MCUMgrParametersReadResponse(message.ReadResponse):\n    \"\"\"Success response to a MCU Manager parameters request.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.MCUMGR_PARAMETERS\n\n    buf_size: int\n    \"\"\"Single SMP buffer size, this includes SMP header and CBOR payload.\"\"\"\n    buf_count: int\n    \"\"\"Number of SMP buffers.\"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.MCUMgrParametersReadResponse.buf_size","title":"<code>buf_size: int</code>  <code>instance-attribute</code>","text":"<p>Single SMP buffer size, this includes SMP header and CBOR payload.</p>"},{"location":"os_management/#smp.os_management.MCUMgrParametersReadResponse.buf_count","title":"<code>buf_count: int</code>  <code>instance-attribute</code>","text":"<p>Number of SMP buffers.</p>"},{"location":"os_management/#smp.os_management.OSApplicationInfoReadRequest","title":"<code>OSApplicationInfoReadRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Request information about the application running on the device.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class OSApplicationInfoReadRequest(message.ReadRequest):\n    \"\"\"Request information about the application running on the device.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.OS_APPLICATION_INFO\n\n    format: str | None = None\n    \"\"\"Format specifier of returned response.\n\n    Fields are appended in their natural ascending index order, not the order\n    of characters that are received by the command.\n\n    Format specifiers:\n    * `s` Kernel name\n    * `n` Node name\n    * `r` Kernel release\n    * `v` Kernel version\n    * `b` Build date and time (requires `CONFIG_MCUMGR_GRP_OS_INFO_BUILD_DATE_TIME`)\n    * `m` Machine\n    * `p` Processor\n    * `i` Hardware platform\n    * `o` Operating system\n    * `a` All fields (shorthand for all above options)\n\n    If this option is not provided, the `s` Kernel name option will be used.\n    \"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.OSApplicationInfoReadRequest.format","title":"<code>format: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Format specifier of returned response.</p> <p>Fields are appended in their natural ascending index order, not the order of characters that are received by the command.</p> <p>Format specifiers: * <code>s</code> Kernel name * <code>n</code> Node name * <code>r</code> Kernel release * <code>v</code> Kernel version * <code>b</code> Build date and time (requires <code>CONFIG_MCUMGR_GRP_OS_INFO_BUILD_DATE_TIME</code>) * <code>m</code> Machine * <code>p</code> Processor * <code>i</code> Hardware platform * <code>o</code> Operating system * <code>a</code> All fields (shorthand for all above options)</p> <p>If this option is not provided, the <code>s</code> Kernel name option will be used.</p>"},{"location":"os_management/#smp.os_management.OSApplicationInfoReadResponse","title":"<code>OSApplicationInfoReadResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Success response to an application information request.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class OSApplicationInfoReadResponse(message.ReadResponse):\n    \"\"\"Success response to an application information request.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.OS_APPLICATION_INFO\n\n    output: str\n    \"\"\"Text response including requested parameters.\"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.OSApplicationInfoReadResponse.output","title":"<code>output: str</code>  <code>instance-attribute</code>","text":"<p>Text response including requested parameters.</p>"},{"location":"os_management/#smp.os_management.BootloaderInformationReadRequest","title":"<code>BootloaderInformationReadRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Request bootloader information.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class BootloaderInformationReadRequest(message.ReadRequest):\n    \"\"\"Request bootloader information.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.BOOTLOADER_INFO\n\n    query: str | None = None\n    \"\"\"Is string representing query for parameters.\n\n    With no restrictions how the query looks like as processing of query is left\n    for bootloader backend. If there is no query, then response will return string\n    identifying the bootloader.\n\n    MCUboot supports the query string,\"mode\".  The response to mode is of type\n    `MCUbootMode`.\n    \"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.BootloaderInformationReadRequest.query","title":"<code>query: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Is string representing query for parameters.</p> <p>With no restrictions how the query looks like as processing of query is left for bootloader backend. If there is no query, then response will return string identifying the bootloader.</p> <p>MCUboot supports the query string,\"mode\".  The response to mode is of type <code>MCUbootMode</code>.</p>"},{"location":"os_management/#smp.os_management.MCUbootMode","title":"<code>MCUbootMode</code>","text":"<p>               Bases: <code>IntEnum</code></p> Source code in <code>smp\\os_management.py</code> <pre><code>@unique\nclass MCUbootMode(IntEnum):\n    UNKNOWN = -1\n    APPLICATION = 0\n    SWAP_USING_SCRATCH = 1\n    OVERWRITE_ONLY = 2\n    SWAP_WITHOUT_SCRATCH = 3\n    DIRECT_XIP_WITHOUT_REVERT = 4\n    DIRECT_XIP_WITH_REVERT = 5\n    RAM_LOADER = 6\n</code></pre>"},{"location":"os_management/#smp.os_management.MCUbootMode.UNKNOWN","title":"<code>UNKNOWN = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootMode.APPLICATION","title":"<code>APPLICATION = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootMode.SWAP_USING_SCRATCH","title":"<code>SWAP_USING_SCRATCH = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootMode.OVERWRITE_ONLY","title":"<code>OVERWRITE_ONLY = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootMode.SWAP_WITHOUT_SCRATCH","title":"<code>SWAP_WITHOUT_SCRATCH = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootMode.DIRECT_XIP_WITHOUT_REVERT","title":"<code>DIRECT_XIP_WITHOUT_REVERT = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootMode.DIRECT_XIP_WITH_REVERT","title":"<code>DIRECT_XIP_WITH_REVERT = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootMode.RAM_LOADER","title":"<code>RAM_LOADER = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootModeQueryResponse","title":"<code>MCUbootModeQueryResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response to a MCUboot mode query.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class MCUbootModeQueryResponse(BaseModel):\n    \"\"\"Response to a MCUboot mode query.\"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", frozen=True)\n\n    mode: MCUbootMode\n    no_downgrade: bool | None = Field(alias=\"no-downgrade\", default=None)\n</code></pre>"},{"location":"os_management/#smp.os_management.MCUbootModeQueryResponse.model_config","title":"<code>model_config = ConfigDict(extra='forbid', frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootModeQueryResponse.mode","title":"<code>mode: MCUbootMode</code>  <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.MCUbootModeQueryResponse.no_downgrade","title":"<code>no_downgrade: bool | None = Field(alias='no-downgrade', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"os_management/#smp.os_management.BootloaderInformationReadResponse","title":"<code>BootloaderInformationReadResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Success response to a bootloader information request.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class BootloaderInformationReadResponse(message.ReadResponse):\n    \"\"\"Success response to a bootloader information request.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n    _COMMAND_ID = header.CommandId.OSManagement.BOOTLOADER_INFO\n\n    bootloader: str\n    \"\"\"String identifying the bootloader.  For MCUboot it will be \"MCUboot\".\"\"\"\n    response: MCUbootModeQueryResponse | Any | None = None\n    \"\"\"Response to \u201cquery\u201d.\n\n    This is optional and may be left out in case when query yields no response,\n    SMP version 2 error code of `OS_MGMT_ERR_QUERY_YIELDS_NO_ANSWER` is\n    expected. Response may have more than one parameter reported back or it may\n    be a map, that is dependent on bootloader backend and query.\"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.BootloaderInformationReadResponse.bootloader","title":"<code>bootloader: str</code>  <code>instance-attribute</code>","text":"<p>String identifying the bootloader.  For MCUboot it will be \"MCUboot\".</p>"},{"location":"os_management/#smp.os_management.BootloaderInformationReadResponse.response","title":"<code>response: MCUbootModeQueryResponse | Any | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Response to \u201cquery\u201d.</p> <p>This is optional and may be left out in case when query yields no response, SMP version 2 error code of <code>OS_MGMT_ERR_QUERY_YIELDS_NO_ANSWER</code> is expected. Response may have more than one parameter reported back or it may be a map, that is dependent on bootloader backend and query.</p>"},{"location":"os_management/#smp.os_management.OS_MGMT_RET_RC","title":"<code>OS_MGMT_RET_RC</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>OS Management return codes.</p> Source code in <code>smp\\os_management.py</code> <pre><code>@unique\nclass OS_MGMT_RET_RC(IntEnum):\n    \"\"\"OS Management return codes.\"\"\"\n\n    OK = 0\n    \"\"\"No error, this is implied if there is no ret value in the response.\"\"\"\n\n    UNKNOWN = 1\n    \"\"\"Unknown error occurred.\"\"\"\n\n    INVALID_FORMAT = 2\n    \"\"\"The provided format value is not valid.\"\"\"\n\n    QUERY_YIELDS_NO_ANSWER = 3\n    \"\"\"Query was not recognized.\"\"\"\n\n    RTC_NOT_SET = 4\n    \"\"\"RTC is not set.\"\"\"\n\n    RTC_COMMAND_FAILED = 5\n    \"\"\"RTC command failed.\"\"\"\n</code></pre>"},{"location":"os_management/#smp.os_management.OS_MGMT_RET_RC.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No error, this is implied if there is no ret value in the response.</p>"},{"location":"os_management/#smp.os_management.OS_MGMT_RET_RC.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown error occurred.</p>"},{"location":"os_management/#smp.os_management.OS_MGMT_RET_RC.INVALID_FORMAT","title":"<code>INVALID_FORMAT = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided format value is not valid.</p>"},{"location":"os_management/#smp.os_management.OS_MGMT_RET_RC.QUERY_YIELDS_NO_ANSWER","title":"<code>QUERY_YIELDS_NO_ANSWER = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Query was not recognized.</p>"},{"location":"os_management/#smp.os_management.OS_MGMT_RET_RC.RTC_NOT_SET","title":"<code>RTC_NOT_SET = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>RTC is not set.</p>"},{"location":"os_management/#smp.os_management.OS_MGMT_RET_RC.RTC_COMMAND_FAILED","title":"<code>RTC_COMMAND_FAILED = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>RTC command failed.</p>"},{"location":"os_management/#smp.os_management.OSManagementErrorV1","title":"<code>OSManagementErrorV1</code>","text":"<p>               Bases: <code>ErrorV1</code></p> <p>OS Management error response.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class OSManagementErrorV1(error.ErrorV1):\n    \"\"\"OS Management error response.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n</code></pre>"},{"location":"os_management/#smp.os_management.OSManagementErrorV2","title":"<code>OSManagementErrorV2</code>","text":"<p>               Bases: <code>ErrorV2[OS_MGMT_RET_RC]</code></p> <p>OS Management error response.</p> Source code in <code>smp\\os_management.py</code> <pre><code>class OSManagementErrorV2(error.ErrorV2[OS_MGMT_RET_RC]):\n    \"\"\"OS Management error response.\"\"\"\n\n    _GROUP_ID = header.GroupId.OS_MANAGEMENT\n</code></pre>"},{"location":"packet/","title":"Packet en/de-coding and fragmentation/reassembly","text":"<p>Generators for encoding and decoding Simple Management Protocol (SMP) packets.</p>"},{"location":"packet/#smp.packet.encode","title":"<code>encode(request: bytes, line_length: int = 8192) -&gt; Generator[bytes, None, None]</code>","text":"<p>Iteratively pack an SMP bytes to packets of <code>line_length</code> size.</p> <p>Note: only the USB/serial transport uses this encoding and fragmentation. The BLE and UDP transports can simply send the SMP frames as they are.</p> <p>Params: - request: The bytes to be encoded. - line_length: The maximum length of each packet.</p> <p>Example:</p> <p>Encode arbitrary bytes to SMP packets:</p> <p><pre><code>from smp.packet import encode\n\nfor packet in encode(b\"Hello, world!\"):\n    print(packet)\n</code></pre> prints: <pre><code>b'\\x06\\tAA9IZWxsbywgd29ybGQhet4=\\n'\n</code></pre></p> <p>Set a smaller packet size to fragment:</p> <p><pre><code>from smp.packet import encode\n\nfor packet in encode(b\"Hello, world!\", line_length=8):\n    print(packet)\n</code></pre> prints: <pre><code>b'\\x06\\tAA9I\\n'\nb'\\x04\\x14ZWxs\\n'\nb'\\x04\\x14bywg\\n'\nb'\\x04\\x14d29y\\n'\nb'\\x04\\x14bGQh\\n'\nb'\\x04\\x14et4=\\n'\n</code></pre></p> <p>The packet size should be set according to the buffer sizes of the SMP server, and larger buffers will be more efficient.  It is not necessary to use multiple buffers.</p> Source code in <code>smp\\packet.py</code> <pre><code>def encode(request: bytes, line_length: int = 8192) -&gt; Generator[bytes, None, None]:\n    \"\"\"Iteratively pack an SMP bytes to packets of `line_length` size.\n\n    Note: only the USB/serial transport uses this encoding and fragmentation.\n    The BLE and UDP transports can simply send the SMP frames as they are.\n\n    Params:\n    - request: The bytes to be encoded.\n    - line_length: The maximum length of each packet.\n\n    Example:\n\n    Encode arbitrary bytes to SMP packets:\n\n    ```python\n    from smp.packet import encode\n\n    for packet in encode(b\"Hello, world!\"):\n        print(packet)\n    ```\n    prints:\n    ```\n    b'\\\\x06\\\\tAA9IZWxsbywgd29ybGQhet4=\\\\n'\n    ```\n\n    Set a smaller packet size to fragment:\n\n    ```python\n    from smp.packet import encode\n\n    for packet in encode(b\"Hello, world!\", line_length=8):\n        print(packet)\n    ```\n    prints:\n    ```\n    b'\\\\x06\\\\tAA9I\\\\n'\n    b'\\\\x04\\\\x14ZWxs\\\\n'\n    b'\\\\x04\\\\x14bywg\\\\n'\n    b'\\\\x04\\\\x14d29y\\\\n'\n    b'\\\\x04\\\\x14bGQh\\\\n'\n    b'\\\\x04\\\\x14et4=\\\\n'\n    ```\n\n    The packet size should be set according to the buffer sizes of the SMP\n    server, and larger buffers will be more efficient.  It is not necessary to\n    use multiple buffers.\n    \"\"\"\n\n    logger.debug(f\"Serializing {request=}\")\n\n    crc16 = CRC16_STRUCT.pack(crc16_func(request))\n    frame_length = FRAME_LENGTH_STRUCT.pack(len(request) + CRC16_STRUCT.size)\n\n    total_size = FRAME_LENGTH_STRUCT.size + len(request) + CRC16_STRUCT.size\n    logger.debug(f\"Total size of request is {total_size}B\")\n\n    packet_size = ((line_length - LINE_LENGTH_SUBTRACTOR) // 4) * 4\n\n    complete_b64 = b64encode(frame_length + request + crc16)\n    logger.debug(f\"Total size of b64 encoded request is {len(complete_b64)}B\")\n\n    # send the start delimiter, as many bytes as possible, and newline\n    yield START_DELIMITER + complete_b64[:packet_size] + END_DELIMITER\n\n    remaining = complete_b64[packet_size:]\n\n    while len(remaining) &gt; 0:\n        # send the continue delimiter, as many bytes as possible, and newline\n        yield CONTINUE_DELIMITER + remaining[:packet_size] + END_DELIMITER\n        remaining = remaining[packet_size:]\n</code></pre>"},{"location":"packet/#smp.packet.decode","title":"<code>decode() -&gt; Generator[None, bytes, bytes]</code>","text":"<p>Iteratively unpack a series of SMP packets to SMP frame bytes.</p> <p>Example:</p> <p><pre><code>from smp.packet import decode\nfrom smp.image_management import ImageUploadWriteRequest\n\n# Example encoded SMP packets\npackets = (\n    bytes.fromhex(\"06094148344b41414230414147610a\"),\n    bytes.fromhex(\"041441615a6a6247567544574e760a\"),\n    bytes.fromhex(\"04145a6d59594b6d4e7a6147464d0a\"),\n    bytes.fromhex(\"041464484a3163335167625755670a\"),\n    bytes.fromhex(\"0414596e4a765a475268644746590a\"),\n    bytes.fromhex(\"04145141414241674d45425159480a\"),\n    bytes.fromhex(\"041443416b4b4377774e446738510a\"),\n    bytes.fromhex(\"041445524954464255574678675a0a\"),\n    bytes.fromhex(\"04144768736348523466494345690a\"),\n    bytes.fromhex(\"04144979516c4a69636f4b536f720a\"),\n    bytes.fromhex(\"04144c4330754c7a41784d6a4d300a\"),\n    bytes.fromhex(\"04144e5459334f446b364f7a77390a\"),\n    bytes.fromhex(\"0414506a396c615731685a3255410a\"),\n    bytes.fromhex(\"04145a3356775a334a685a4758300a\"),\n    bytes.fromhex(\"04147134673d0a\"),\n)\n\ndecoder = decode()\nnext(decoder)\n\nfor packet in packets:\n    try:\n        decoder.send(packet)\n    except StopIteration as e:\n        frame = e.value\n        break\n\nprint(frame)\nprint(ImageUploadWriteRequest.loads(frame))\n</code></pre> prints: <pre><code>bytearray(b'\\n\\x00\\x00t\\x00\\x01\\x9a\\x01\\xa6clen\\rcoff\\x18*cshaLtrust me broddataX@\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&amp;\\'()*+,-./0123456789:;&lt;=&gt;?eimage\\x00gupgrade\\xf4')  # noqa: E501\n</code></pre> and <pre><code>header=Header(op=&lt;OP.WRITE: 2&gt;, version=&lt;Version.V2: 1&gt;, flags=&lt;Flag: 0&gt;,\nlength=116, group_id=1, sequence=154, command_id=1) version=&lt;Version.V2: 1&gt;\nsequence=154 smp_data=b'\\n\\x00\\x00t\\x00\\x01\\x9a\\x01\\xa6clen\\rcoff\\x18*cshaL\ntrust me broddataX@\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\n\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&amp;\n\\'()*+,-./0123456789:;&lt;=&gt;?eimage\\x00gupgrade\\xf4' off=42 data=b'\\x00\\x01\\x02\n\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\n\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&amp;\\'()*+,-./0123456789:;&lt;=&gt;?'\nimage=0 len=13 sha=b'trust me bro' upgrade=False\n</code></pre></p> Source code in <code>smp\\packet.py</code> <pre><code>def decode() -&gt; Generator[None, bytes, bytes]:\n    \"\"\"Iteratively unpack a series of SMP packets to SMP frame bytes.\n\n    Example:\n\n    ```python\n    from smp.packet import decode\n    from smp.image_management import ImageUploadWriteRequest\n\n    # Example encoded SMP packets\n    packets = (\n        bytes.fromhex(\"06094148344b41414230414147610a\"),\n        bytes.fromhex(\"041441615a6a6247567544574e760a\"),\n        bytes.fromhex(\"04145a6d59594b6d4e7a6147464d0a\"),\n        bytes.fromhex(\"041464484a3163335167625755670a\"),\n        bytes.fromhex(\"0414596e4a765a475268644746590a\"),\n        bytes.fromhex(\"04145141414241674d45425159480a\"),\n        bytes.fromhex(\"041443416b4b4377774e446738510a\"),\n        bytes.fromhex(\"041445524954464255574678675a0a\"),\n        bytes.fromhex(\"04144768736348523466494345690a\"),\n        bytes.fromhex(\"04144979516c4a69636f4b536f720a\"),\n        bytes.fromhex(\"04144c4330754c7a41784d6a4d300a\"),\n        bytes.fromhex(\"04144e5459334f446b364f7a77390a\"),\n        bytes.fromhex(\"0414506a396c615731685a3255410a\"),\n        bytes.fromhex(\"04145a3356775a334a685a4758300a\"),\n        bytes.fromhex(\"04147134673d0a\"),\n    )\n\n    decoder = decode()\n    next(decoder)\n\n    for packet in packets:\n        try:\n            decoder.send(packet)\n        except StopIteration as e:\n            frame = e.value\n            break\n\n    print(frame)\n    print(ImageUploadWriteRequest.loads(frame))\n    ```\n    prints:\n    ```\n    bytearray(b'\\\\n\\\\x00\\\\x00t\\\\x00\\\\x01\\\\x9a\\\\x01\\\\xa6clen\\\\rcoff\\\\x18*cshaLtrust me broddataX@\\\\x00\\\\x01\\\\x02\\\\x03\\\\x04\\\\x05\\\\x06\\\\x07\\\\x08\\\\t\\\\n\\\\x0b\\\\x0c\\\\r\\\\x0e\\\\x0f\\\\x10\\\\x11\\\\x12\\\\x13\\\\x14\\\\x15\\\\x16\\\\x17\\\\x18\\\\x19\\\\x1a\\\\x1b\\\\x1c\\\\x1d\\\\x1e\\\\x1f !\"#$%&amp;\\\\'()*+,-./0123456789:;&lt;=&gt;?eimage\\\\x00gupgrade\\\\xf4')  # noqa: E501\n    ```\n    and\n    ```\n    header=Header(op=&lt;OP.WRITE: 2&gt;, version=&lt;Version.V2: 1&gt;, flags=&lt;Flag: 0&gt;,\n    length=116, group_id=1, sequence=154, command_id=1) version=&lt;Version.V2: 1&gt;\n    sequence=154 smp_data=b'\\\\n\\\\x00\\\\x00t\\\\x00\\\\x01\\\\x9a\\\\x01\\\\xa6clen\\\\rcoff\\\\x18*cshaL\n    trust me broddataX@\\\\x00\\\\x01\\\\x02\\\\x03\\\\x04\\\\x05\\\\x06\\\\x07\\\\x08\\\\t\\\\n\\\\x0b\\\\x0c\\\\r\\\\x0e\n    \\\\x0f\\\\x10\\\\x11\\\\x12\\\\x13\\\\x14\\\\x15\\\\x16\\\\x17\\\\x18\\\\x19\\\\x1a\\\\x1b\\\\x1c\\\\x1d\\\\x1e\\\\x1f !\"#$%&amp;\n    \\\\'()*+,-./0123456789:;&lt;=&gt;?eimage\\\\x00gupgrade\\\\xf4' off=42 data=b'\\\\x00\\\\x01\\\\x02\n    \\\\x03\\\\x04\\\\x05\\\\x06\\\\x07\\\\x08\\\\t\\\\n\\\\x0b\\\\x0c\\\\r\\\\x0e\\\\x0f\\\\x10\\\\x11\\\\x12\\\\x13\\\\x14\\\\x15\\\\x16\n    \\\\x17\\\\x18\\\\x19\\\\x1a\\\\x1b\\\\x1c\\\\x1d\\\\x1e\\\\x1f !\"#$%&amp;\\\\'()*+,-./0123456789:;&lt;=&gt;?'\n    image=0 len=13 sha=b'trust me bro' upgrade=False\n    ```\n    \"\"\"\n\n    packet = yield\n\n    if packet[:DELIMITER_SIZE] != START_DELIMITER:\n        raise SMPBadStartDelimiter(f\"Bad start delimiter {packet[:DELIMITER_SIZE].hex()}\")\n\n    length_and_frame = b64decode(packet[DELIMITER_SIZE : -len(END_DELIMITER)])\n    frame_length = FRAME_LENGTH_STRUCT.unpack(length_and_frame[: FRAME_LENGTH_STRUCT.size])[0]\n    logger.debug(f\"Response {length_and_frame=}\")\n\n    frame = bytearray(length_and_frame[FRAME_LENGTH_STRUCT.size :])\n    logger.debug(f\"length of frame: {len(frame)}\")\n    while len(frame) &lt; frame_length:\n        packet = yield\n\n        if packet[:DELIMITER_SIZE] != CONTINUE_DELIMITER:\n            raise SMPBadContinueDelimiter(f\"Bad continue delimiter {packet[:DELIMITER_SIZE].hex()}\")\n\n        frame.extend(b64decode(packet[DELIMITER_SIZE : -len(END_DELIMITER)]))\n\n    complete_frame = frame[: -CRC16_STRUCT.size]\n    packet_crc16 = CRC16_STRUCT.unpack(frame[-CRC16_STRUCT.size :])[0]\n    calculated_crc16 = crc16_func(complete_frame)\n\n    if packet_crc16 != calculated_crc16:\n        raise SMPBadCRC(f\"Packet CRC {hex(packet_crc16)} != calculated CRC {hex(calculated_crc16)}\")\n\n    return complete_frame\n</code></pre>"},{"location":"settings_management/","title":"Settings Management","text":"<p>The Simple Management Protocol (SMP) Settings Management group.</p>"},{"location":"settings_management/#smp.settings_management.ReadSettingRequest","title":"<code>ReadSettingRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Read setting.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class ReadSettingRequest(smpmsg.ReadRequest):\n    \"\"\"Read setting.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.READ_WRITE_SETTING\n\n    name: str\n    \"\"\"The name of the setting to read.\"\"\"\n\n    max_size: int | None = None\n    \"\"\"The maximum size of the data to read.\"\"\"\n</code></pre>"},{"location":"settings_management/#smp.settings_management.ReadSettingRequest.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the setting to read.</p>"},{"location":"settings_management/#smp.settings_management.ReadSettingRequest.max_size","title":"<code>max_size: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum size of the data to read.</p>"},{"location":"settings_management/#smp.settings_management.ReadSettingResponse","title":"<code>ReadSettingResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Read setting success response.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class ReadSettingResponse(smpmsg.ReadResponse):\n    \"\"\"Read setting success response.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.READ_WRITE_SETTING\n\n    val: bytes\n    \"\"\"Binary string of the returned data.\n\n    Note that the underlying data type cannot be specified through this and must\n    be known by the client.\n    \"\"\"\n\n    max_size: int | None = None\n    \"\"\"The SMP server supports a smaller size than requested.\n\n    Will be set if the maximum supported data size is smaller than the maximum\n    requested data size, and contains the maximum data size which the device\n    supports, equivalent to `CONFIG_MCUMGR_GRP_SETTINGS_NAME_LEN`.\n    \"\"\"\n</code></pre>"},{"location":"settings_management/#smp.settings_management.ReadSettingResponse.val","title":"<code>val: bytes</code>  <code>instance-attribute</code>","text":"<p>Binary string of the returned data.</p> <p>Note that the underlying data type cannot be specified through this and must be known by the client.</p>"},{"location":"settings_management/#smp.settings_management.ReadSettingResponse.max_size","title":"<code>max_size: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SMP server supports a smaller size than requested.</p> <p>Will be set if the maximum supported data size is smaller than the maximum requested data size, and contains the maximum data size which the device supports, equivalent to <code>CONFIG_MCUMGR_GRP_SETTINGS_NAME_LEN</code>.</p>"},{"location":"settings_management/#smp.settings_management.WriteSettingRequest","title":"<code>WriteSettingRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Write setting.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class WriteSettingRequest(smpmsg.WriteRequest):\n    \"\"\"Write setting.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.READ_WRITE_SETTING\n\n    name: str\n    \"\"\"The name of the setting to write.\"\"\"\n\n    val: bytes\n    \"\"\"Binary data to write.\"\"\"\n</code></pre>"},{"location":"settings_management/#smp.settings_management.WriteSettingRequest.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the setting to write.</p>"},{"location":"settings_management/#smp.settings_management.WriteSettingRequest.val","title":"<code>val: bytes</code>  <code>instance-attribute</code>","text":"<p>Binary data to write.</p>"},{"location":"settings_management/#smp.settings_management.WriteSettingResponse","title":"<code>WriteSettingResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Write setting success response.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class WriteSettingResponse(smpmsg.WriteResponse):\n    \"\"\"Write setting success response.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.READ_WRITE_SETTING\n</code></pre>"},{"location":"settings_management/#smp.settings_management.DeleteSettingRequest","title":"<code>DeleteSettingRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Delete setting.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class DeleteSettingRequest(smpmsg.WriteRequest):\n    \"\"\"Delete setting.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.DELETE_SETTING\n\n    name: str\n    \"\"\"The name of the setting to delete.\"\"\"\n</code></pre>"},{"location":"settings_management/#smp.settings_management.DeleteSettingRequest.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the setting to delete.</p>"},{"location":"settings_management/#smp.settings_management.DeleteSettingResponse","title":"<code>DeleteSettingResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Delete setting success response.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class DeleteSettingResponse(smpmsg.WriteResponse):\n    \"\"\"Delete setting success response.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.DELETE_SETTING\n</code></pre>"},{"location":"settings_management/#smp.settings_management.CommitSettingsRequest","title":"<code>CommitSettingsRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Commit pending settings.</p> <p>Commit settings command allows committing all settings that have been set but not yet applied on a device.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class CommitSettingsRequest(smpmsg.WriteRequest):\n    \"\"\"Commit pending settings.\n\n    Commit settings command allows committing all settings that have been set\n    but not yet applied on a device.\n    \"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.COMMIT_SETTINGS\n</code></pre>"},{"location":"settings_management/#smp.settings_management.CommitSettingsResponse","title":"<code>CommitSettingsResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Commit pending settings success response.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class CommitSettingsResponse(smpmsg.WriteResponse):\n    \"\"\"Commit pending settings success response.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.COMMIT_SETTINGS\n</code></pre>"},{"location":"settings_management/#smp.settings_management.LoadSettingsRequest","title":"<code>LoadSettingsRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Load settings from persistent storage.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class LoadSettingsRequest(smpmsg.ReadRequest):\n    \"\"\"Load settings from persistent storage.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.LOAD_SAVE_SETTINGS\n</code></pre>"},{"location":"settings_management/#smp.settings_management.LoadSettingsResponse","title":"<code>LoadSettingsResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Load settings from persistent storage success response.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class LoadSettingsResponse(smpmsg.ReadResponse):\n    \"\"\"Load settings from persistent storage success response.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.LOAD_SAVE_SETTINGS\n</code></pre>"},{"location":"settings_management/#smp.settings_management.SaveSettingsRequest","title":"<code>SaveSettingsRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Save settings to persistent storage.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class SaveSettingsRequest(smpmsg.WriteRequest):\n    \"\"\"Save settings to persistent storage.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.LOAD_SAVE_SETTINGS\n</code></pre>"},{"location":"settings_management/#smp.settings_management.SaveSettingsResponse","title":"<code>SaveSettingsResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Save settings to persistent storage success response.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class SaveSettingsResponse(smpmsg.WriteResponse):\n    \"\"\"Save settings to persistent storage success response.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.SettingsManagement.LOAD_SAVE_SETTINGS\n</code></pre>"},{"location":"settings_management/#smp.settings_management.SETTINGS_MGMT_ERR","title":"<code>SETTINGS_MGMT_ERR</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Return codes for the settings management group.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>@unique\nclass SETTINGS_MGMT_ERR(IntEnum):\n    \"\"\"Return codes for the settings management group.\"\"\"\n\n    OK = 0\n    \"\"\"No error, this is implied if there is no ret value in the response.\"\"\"\n\n    UNKNOWN = 1\n    \"\"\"Unknown error occurred.\"\"\"\n\n    KEY_TOO_LONG = 2\n    \"\"\"The provided key name is too long to be used.\"\"\"\n\n    KEY_NOT_FOUND = 3\n    \"\"\"The provided key name does not exist.\"\"\"\n\n    READ_NOT_SUPPORTED = 4\n    \"\"\"The provided key name does not support being read.\"\"\"\n\n    ROOT_KEY_NOT_FOUND = 5\n    \"\"\"The provided root key name does not exist.\"\"\"\n\n    WRITE_NOT_SUPPORTED = 6\n    \"\"\"The provided key name does not support being written.\"\"\"\n\n    DELETE_NOT_SUPPORTED = 7\n    \"\"\"The provided key name does not support being deleted.\"\"\"\n</code></pre>"},{"location":"settings_management/#smp.settings_management.SETTINGS_MGMT_ERR.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No error, this is implied if there is no ret value in the response.</p>"},{"location":"settings_management/#smp.settings_management.SETTINGS_MGMT_ERR.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown error occurred.</p>"},{"location":"settings_management/#smp.settings_management.SETTINGS_MGMT_ERR.KEY_TOO_LONG","title":"<code>KEY_TOO_LONG = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided key name is too long to be used.</p>"},{"location":"settings_management/#smp.settings_management.SETTINGS_MGMT_ERR.KEY_NOT_FOUND","title":"<code>KEY_NOT_FOUND = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided key name does not exist.</p>"},{"location":"settings_management/#smp.settings_management.SETTINGS_MGMT_ERR.READ_NOT_SUPPORTED","title":"<code>READ_NOT_SUPPORTED = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided key name does not support being read.</p>"},{"location":"settings_management/#smp.settings_management.SETTINGS_MGMT_ERR.ROOT_KEY_NOT_FOUND","title":"<code>ROOT_KEY_NOT_FOUND = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided root key name does not exist.</p>"},{"location":"settings_management/#smp.settings_management.SETTINGS_MGMT_ERR.WRITE_NOT_SUPPORTED","title":"<code>WRITE_NOT_SUPPORTED = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided key name does not support being written.</p>"},{"location":"settings_management/#smp.settings_management.SETTINGS_MGMT_ERR.DELETE_NOT_SUPPORTED","title":"<code>DELETE_NOT_SUPPORTED = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided key name does not support being deleted.</p>"},{"location":"settings_management/#smp.settings_management.SettingsManagementErrorV1","title":"<code>SettingsManagementErrorV1</code>","text":"<p>               Bases: <code>ErrorV1</code></p> <p>Error response to a settings management command.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class SettingsManagementErrorV1(smperr.ErrorV1):\n    \"\"\"Error response to a settings management command.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n</code></pre>"},{"location":"settings_management/#smp.settings_management.SettingsManagementErrorV2","title":"<code>SettingsManagementErrorV2</code>","text":"<p>               Bases: <code>ErrorV2[SETTINGS_MGMT_ERR]</code></p> <p>Error response to a settings management command.</p> Source code in <code>smp\\settings_management.py</code> <pre><code>class SettingsManagementErrorV2(smperr.ErrorV2[SETTINGS_MGMT_ERR]):\n    \"\"\"Error response to a settings management command.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.SETTINGS_MANAGEMENT\n</code></pre>"},{"location":"shell_management/","title":"Shell Management","text":"<p>The Simple Management Protocol (SMP) Shell Management group.</p>"},{"location":"shell_management/#smp.shell_management.ExecuteRequest","title":"<code>ExecuteRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Execute a shell command.</p> Source code in <code>smp\\shell_management.py</code> <pre><code>class ExecuteRequest(message.WriteRequest):\n    \"\"\"Execute a shell command.\"\"\"\n\n    _GROUP_ID = header.GroupId.SHELL_MANAGEMENT\n    _COMMAND_ID = header.CommandId.ShellManagement.EXECUTE\n\n    argv: List[str]\n</code></pre>"},{"location":"shell_management/#smp.shell_management.ExecuteRequest.argv","title":"<code>argv: List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"shell_management/#smp.shell_management.ExecuteResponse","title":"<code>ExecuteResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to a shell command execution.</p> Source code in <code>smp\\shell_management.py</code> <pre><code>class ExecuteResponse(message.WriteResponse):\n    \"\"\"Success response to a shell command execution.\"\"\"\n\n    _GROUP_ID = header.GroupId.SHELL_MANAGEMENT\n    _COMMAND_ID = header.CommandId.ShellManagement.EXECUTE\n\n    o: str\n    ret: int\n</code></pre>"},{"location":"shell_management/#smp.shell_management.ExecuteResponse.o","title":"<code>o: str</code>  <code>instance-attribute</code>","text":""},{"location":"shell_management/#smp.shell_management.ExecuteResponse.ret","title":"<code>ret: int</code>  <code>instance-attribute</code>","text":""},{"location":"shell_management/#smp.shell_management.SHELL_MGMT_RET_RC","title":"<code>SHELL_MGMT_RET_RC</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Return codes for the shell management group.</p> Source code in <code>smp\\shell_management.py</code> <pre><code>@unique\nclass SHELL_MGMT_RET_RC(IntEnum):\n    \"\"\"Return codes for the shell management group.\"\"\"\n\n    OK = 0\n    \"\"\"No error, this is implied if there is no ret value in the response.\"\"\"\n\n    UNKNOWN = 1\n    \"\"\"Unknown error occurred.\"\"\"\n\n    INVALID_FORMAT = 2\n    \"\"\"The provided format value is not valid.\"\"\"\n</code></pre>"},{"location":"shell_management/#smp.shell_management.SHELL_MGMT_RET_RC.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No error, this is implied if there is no ret value in the response.</p>"},{"location":"shell_management/#smp.shell_management.SHELL_MGMT_RET_RC.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown error occurred.</p>"},{"location":"shell_management/#smp.shell_management.SHELL_MGMT_RET_RC.INVALID_FORMAT","title":"<code>INVALID_FORMAT = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided format value is not valid.</p>"},{"location":"shell_management/#smp.shell_management.ShellManagementErrorV1","title":"<code>ShellManagementErrorV1</code>","text":"<p>               Bases: <code>ErrorV1</code></p> <p>Error response to a shell command execution.</p> Source code in <code>smp\\shell_management.py</code> <pre><code>class ShellManagementErrorV1(error.ErrorV1):\n    \"\"\"Error response to a shell command execution.\"\"\"\n\n    _GROUP_ID = header.GroupId.SHELL_MANAGEMENT\n</code></pre>"},{"location":"shell_management/#smp.shell_management.ShellManagementErrorV2","title":"<code>ShellManagementErrorV2</code>","text":"<p>               Bases: <code>ErrorV2[SHELL_MGMT_RET_RC]</code></p> <p>Error response to a shell command execution.</p> Source code in <code>smp\\shell_management.py</code> <pre><code>class ShellManagementErrorV2(error.ErrorV2[SHELL_MGMT_RET_RC]):\n    \"\"\"Error response to a shell command execution.\"\"\"\n\n    _GROUP_ID = header.GroupId.SHELL_MANAGEMENT\n</code></pre>"},{"location":"statistics_management/","title":"Statistics Management","text":"<p>The Simple Management Protocol (SMP) Statistics Management group.</p>"},{"location":"statistics_management/#smp.statistics_management.GroupDataRequest","title":"<code>GroupDataRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>Read the statistics group data.</p> Source code in <code>smp\\statistics_management.py</code> <pre><code>class GroupDataRequest(smpmsg.ReadRequest):\n    \"\"\"Read the statistics group data.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.STATISTICS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.StatisticsManagement.GROUP_DATA\n\n    name: str\n</code></pre>"},{"location":"statistics_management/#smp.statistics_management.GroupDataRequest.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"statistics_management/#smp.statistics_management.GroupDataResponse","title":"<code>GroupDataResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>Statistics group data response.</p> Source code in <code>smp\\statistics_management.py</code> <pre><code>class GroupDataResponse(smpmsg.ReadResponse):\n    \"\"\"Statistics group data response.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.STATISTICS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.StatisticsManagement.GROUP_DATA\n\n    name: str\n    fields: Dict[str, int]\n</code></pre>"},{"location":"statistics_management/#smp.statistics_management.GroupDataResponse.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"statistics_management/#smp.statistics_management.GroupDataResponse.fields","title":"<code>fields: Dict[str, int]</code>  <code>instance-attribute</code>","text":""},{"location":"statistics_management/#smp.statistics_management.ListOfGroupsRequest","title":"<code>ListOfGroupsRequest</code>","text":"<p>               Bases: <code>ReadRequest</code></p> <p>List the available statistics groups.</p> Source code in <code>smp\\statistics_management.py</code> <pre><code>class ListOfGroupsRequest(smpmsg.ReadRequest):\n    \"\"\"List the available statistics groups.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.STATISTICS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.StatisticsManagement.LIST_OF_GROUPS\n</code></pre>"},{"location":"statistics_management/#smp.statistics_management.ListOfGroupsResponse","title":"<code>ListOfGroupsResponse</code>","text":"<p>               Bases: <code>ReadResponse</code></p> <p>List of available statistics groups.</p> Source code in <code>smp\\statistics_management.py</code> <pre><code>class ListOfGroupsResponse(smpmsg.ReadResponse):\n    \"\"\"List of available statistics groups.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.STATISTICS_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.StatisticsManagement.LIST_OF_GROUPS\n\n    stat_list: Tuple[str, ...]\n</code></pre>"},{"location":"statistics_management/#smp.statistics_management.ListOfGroupsResponse.stat_list","title":"<code>stat_list: Tuple[str, ...]</code>  <code>instance-attribute</code>","text":""},{"location":"statistics_management/#smp.statistics_management.STAT_MGMT_ERR","title":"<code>STAT_MGMT_ERR</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Return codes for the statistics management group.</p> Source code in <code>smp\\statistics_management.py</code> <pre><code>@unique\nclass STAT_MGMT_ERR(IntEnum):\n    \"\"\"Return codes for the statistics management group.\"\"\"\n\n    OK = 0\n    \"\"\"No error, this is implied if there is no ret value in the response.\"\"\"\n\n    UNKNOWN = 1\n    \"\"\"Unknown error occurred.\"\"\"\n\n    ERR_INVALID_GROUP = 2\n    \"\"\"The provided statistic group name was not found.\"\"\"\n\n    ERR_INVALID_STAT_NAME = 3\n    \"\"\"The provided statistic name was not found.\"\"\"\n\n    ERR_INVALID_STAT_SIZE = 4\n    \"\"\"The size of the statistic cannot be handled.\"\"\"\n\n    ERR_WALK_ABORTED = 5\n    \"\"\"Walk through of statistics was aborted.\"\"\"\n</code></pre>"},{"location":"statistics_management/#smp.statistics_management.STAT_MGMT_ERR.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No error, this is implied if there is no ret value in the response.</p>"},{"location":"statistics_management/#smp.statistics_management.STAT_MGMT_ERR.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown error occurred.</p>"},{"location":"statistics_management/#smp.statistics_management.STAT_MGMT_ERR.ERR_INVALID_GROUP","title":"<code>ERR_INVALID_GROUP = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided statistic group name was not found.</p>"},{"location":"statistics_management/#smp.statistics_management.STAT_MGMT_ERR.ERR_INVALID_STAT_NAME","title":"<code>ERR_INVALID_STAT_NAME = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The provided statistic name was not found.</p>"},{"location":"statistics_management/#smp.statistics_management.STAT_MGMT_ERR.ERR_INVALID_STAT_SIZE","title":"<code>ERR_INVALID_STAT_SIZE = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The size of the statistic cannot be handled.</p>"},{"location":"statistics_management/#smp.statistics_management.STAT_MGMT_ERR.ERR_WALK_ABORTED","title":"<code>ERR_WALK_ABORTED = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Walk through of statistics was aborted.</p>"},{"location":"statistics_management/#smp.statistics_management.StatisticsManagementErrorV1","title":"<code>StatisticsManagementErrorV1</code>","text":"<p>               Bases: <code>ErrorV1</code></p> <p>Error response to a statistics management command.</p> Source code in <code>smp\\statistics_management.py</code> <pre><code>class StatisticsManagementErrorV1(smperr.ErrorV1):\n    \"\"\"Error response to a statistics management command.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.STATISTICS_MANAGEMENT\n</code></pre>"},{"location":"statistics_management/#smp.statistics_management.StatisticsManagementErrorV2","title":"<code>StatisticsManagementErrorV2</code>","text":"<p>               Bases: <code>ErrorV2[STAT_MGMT_ERR]</code></p> <p>Error response to a statistics management command.</p> Source code in <code>smp\\statistics_management.py</code> <pre><code>class StatisticsManagementErrorV2(smperr.ErrorV2[STAT_MGMT_ERR]):\n    \"\"\"Error response to a statistics management command.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.STATISTICS_MANAGEMENT\n</code></pre>"},{"location":"zephyr_management/","title":"Zephyr Management","text":"<p>The Simple Management Protocol (SMP) Zephyr Management group.</p>"},{"location":"zephyr_management/#smp.zephyr_management.EraseStorageRequest","title":"<code>EraseStorageRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Erase the storage area.</p> Source code in <code>smp\\zephyr_management.py</code> <pre><code>class EraseStorageRequest(smpmsg.WriteRequest):\n    \"\"\"Erase the storage area.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.ZEPHYR_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.ZephyrManagement.ERASE_STORAGE\n</code></pre>"},{"location":"zephyr_management/#smp.zephyr_management.EraseStorageResponse","title":"<code>EraseStorageResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to a storage area erase.</p> Source code in <code>smp\\zephyr_management.py</code> <pre><code>class EraseStorageResponse(smpmsg.WriteResponse):\n    \"\"\"Success response to a storage area erase.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.ZEPHYR_MANAGEMENT\n    _COMMAND_ID = smphdr.CommandId.ZephyrManagement.ERASE_STORAGE\n</code></pre>"},{"location":"zephyr_management/#smp.zephyr_management.ZEPHYRBASIC_MGMT_ERR","title":"<code>ZEPHYRBASIC_MGMT_ERR</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Return codes for the Zephyr Management group.</p> Source code in <code>smp\\zephyr_management.py</code> <pre><code>@unique\nclass ZEPHYRBASIC_MGMT_ERR(IntEnum):\n    \"\"\"Return codes for the Zephyr Management group.\"\"\"\n\n    OK = 0\n    \"\"\"No error, this is implied if there is no ret value in the response\"\"\"\n\n    UNKNOWN = 1\n    \"\"\"Unknown error occurred.\"\"\"\n\n    FLASH_OPEN_FAILED = 2\n    \"\"\"Opening of the flash area has failed.\"\"\"\n\n    FLASH_CONFIG_QUERY_FAIL = 3\n    \"\"\"Querying the flash area parameters has failed.\"\"\"\n\n    FLASH_ERASE_FAILED = 4\n    \"\"\"Erasing the flash area has failed.\"\"\"\n</code></pre>"},{"location":"zephyr_management/#smp.zephyr_management.ZEPHYRBASIC_MGMT_ERR.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No error, this is implied if there is no ret value in the response</p>"},{"location":"zephyr_management/#smp.zephyr_management.ZEPHYRBASIC_MGMT_ERR.UNKNOWN","title":"<code>UNKNOWN = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown error occurred.</p>"},{"location":"zephyr_management/#smp.zephyr_management.ZEPHYRBASIC_MGMT_ERR.FLASH_OPEN_FAILED","title":"<code>FLASH_OPEN_FAILED = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Opening of the flash area has failed.</p>"},{"location":"zephyr_management/#smp.zephyr_management.ZEPHYRBASIC_MGMT_ERR.FLASH_CONFIG_QUERY_FAIL","title":"<code>FLASH_CONFIG_QUERY_FAIL = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Querying the flash area parameters has failed.</p>"},{"location":"zephyr_management/#smp.zephyr_management.ZEPHYRBASIC_MGMT_ERR.FLASH_ERASE_FAILED","title":"<code>FLASH_ERASE_FAILED = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Erasing the flash area has failed.</p>"},{"location":"zephyr_management/#smp.zephyr_management.ZephyrManagementErrorV1","title":"<code>ZephyrManagementErrorV1</code>","text":"<p>               Bases: <code>ErrorV1</code></p> <p>Error response to a Zephyr Management command.</p> Source code in <code>smp\\zephyr_management.py</code> <pre><code>class ZephyrManagementErrorV1(smperr.ErrorV1):\n    \"\"\"Error response to a Zephyr Management command.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.ZEPHYR_MANAGEMENT\n</code></pre>"},{"location":"zephyr_management/#smp.zephyr_management.ZephyrManagementErrorV2","title":"<code>ZephyrManagementErrorV2</code>","text":"<p>               Bases: <code>ErrorV2[ZEPHYRBASIC_MGMT_ERR]</code></p> <p>Error response to a Zephyr Management command.</p> Source code in <code>smp\\zephyr_management.py</code> <pre><code>class ZephyrManagementErrorV2(smperr.ErrorV2[ZEPHYRBASIC_MGMT_ERR]):\n    \"\"\"Error response to a Zephyr Management command.\"\"\"\n\n    _GROUP_ID = smphdr.GroupId.ZEPHYR_MANAGEMENT\n</code></pre>"},{"location":"user/intercreate/","title":"Intercreate","text":"<p>The Simple Management Protocol (SMP) Intercreate Management group.</p>"},{"location":"user/intercreate/#smp.user.intercreate.ImageUploadWriteRequest","title":"<code>ImageUploadWriteRequest</code>","text":"<p>               Bases: <code>WriteRequest</code></p> <p>Upload an image to an application-defined location like a secondary MCU.</p> Source code in <code>smp\\user\\intercreate.py</code> <pre><code>class ImageUploadWriteRequest(message.WriteRequest):\n    \"\"\"Upload an image to an application-defined location like a secondary MCU.\"\"\"\n\n    _GROUP_ID = header.UserGroupId.INTERCREATE\n    _COMMAND_ID = header.CommandId.Intercreate.UPLOAD\n\n    off: int\n    \"\"\"The offset in the image to write to.\"\"\"\n\n    data: bytes\n    \"\"\"The data to write to the image.\"\"\"\n\n    image: int | None = None\n    \"\"\"The image to write to; required when off == 0.\"\"\"\n\n    len: int | None = None\n    \"\"\"The length of the data to write; required when off == 0.\"\"\"\n\n    sha: bytes | None = None\n    \"\"\"The SHA-256 hash of the image; optional when off == 0, else ignored.\"\"\"\n</code></pre>"},{"location":"user/intercreate/#smp.user.intercreate.ImageUploadWriteRequest.off","title":"<code>off: int</code>  <code>instance-attribute</code>","text":"<p>The offset in the image to write to.</p>"},{"location":"user/intercreate/#smp.user.intercreate.ImageUploadWriteRequest.data","title":"<code>data: bytes</code>  <code>instance-attribute</code>","text":"<p>The data to write to the image.</p>"},{"location":"user/intercreate/#smp.user.intercreate.ImageUploadWriteRequest.image","title":"<code>image: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The image to write to; required when off == 0.</p>"},{"location":"user/intercreate/#smp.user.intercreate.ImageUploadWriteRequest.len","title":"<code>len: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The length of the data to write; required when off == 0.</p>"},{"location":"user/intercreate/#smp.user.intercreate.ImageUploadWriteRequest.sha","title":"<code>sha: bytes | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SHA-256 hash of the image; optional when off == 0, else ignored.</p>"},{"location":"user/intercreate/#smp.user.intercreate.ImageUploadWriteResponse","title":"<code>ImageUploadWriteResponse</code>","text":"<p>               Bases: <code>WriteResponse</code></p> <p>Success response to an image upload request.</p> Source code in <code>smp\\user\\intercreate.py</code> <pre><code>class ImageUploadWriteResponse(message.WriteResponse):\n    \"\"\"Success response to an image upload request.\"\"\"\n\n    _GROUP_ID = header.UserGroupId.INTERCREATE\n    _COMMAND_ID = header.CommandId.Intercreate.UPLOAD\n\n    off: int\n    \"\"\"The offset in the image after the request was written.\"\"\"\n</code></pre>"},{"location":"user/intercreate/#smp.user.intercreate.ImageUploadWriteResponse.off","title":"<code>off: int</code>  <code>instance-attribute</code>","text":"<p>The offset in the image after the request was written.</p>"},{"location":"user/intercreate/#smp.user.intercreate.IC_MGMT_ERR","title":"<code>IC_MGMT_ERR</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Intercreate Management error codes.</p> Source code in <code>smp\\user\\intercreate.py</code> <pre><code>@unique\nclass IC_MGMT_ERR(IntEnum):\n    \"\"\"Intercreate Management error codes.\"\"\"\n\n    OK = 0\n    \"\"\"No error.\"\"\"\n\n    INVALID_IMAGE = 1\n    \"\"\"No image matched the image provided.\"\"\"\n</code></pre>"},{"location":"user/intercreate/#smp.user.intercreate.IC_MGMT_ERR.OK","title":"<code>OK = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No error.</p>"},{"location":"user/intercreate/#smp.user.intercreate.IC_MGMT_ERR.INVALID_IMAGE","title":"<code>INVALID_IMAGE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No image matched the image provided.</p>"},{"location":"user/intercreate/#smp.user.intercreate.ErrorV1","title":"<code>ErrorV1</code>","text":"<p>               Bases: <code>ErrorV1</code></p> <p>Intercreate Management error response.</p> Source code in <code>smp\\user\\intercreate.py</code> <pre><code>class ErrorV1(error.ErrorV1):\n    \"\"\"Intercreate Management error response.\"\"\"\n\n    _GROUP_ID = header.UserGroupId.INTERCREATE\n</code></pre>"},{"location":"user/intercreate/#smp.user.intercreate.ErrorV2","title":"<code>ErrorV2</code>","text":"<p>               Bases: <code>ErrorV2[IC_MGMT_ERR]</code></p> <p>Intercreate Management error response.</p> Source code in <code>smp\\user\\intercreate.py</code> <pre><code>class ErrorV2(error.ErrorV2[IC_MGMT_ERR]):\n    \"\"\"Intercreate Management error response.\"\"\"\n\n    _GROUP_ID = header.UserGroupId.INTERCREATE\n</code></pre>"}]}